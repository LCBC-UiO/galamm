[{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socioeconomic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://lcbc-uio.github.io/galamm/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://lcbc-uio.github.io/galamm/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://lcbc-uio.github.io/galamm/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://lcbc-uio.github.io/galamm/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement oystein.sorensen.1985@gmail.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://lcbc-uio.github.io/galamm/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://lcbc-uio.github.io/galamm/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://lcbc-uio.github.io/galamm/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://lcbc-uio.github.io/galamm/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://lcbc-uio.github.io/galamm/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://lcbc-uio.github.io/galamm/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://lcbc-uio.github.io/galamm/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to galamm","title":"Contributing to galamm","text":"outlines propose change galamm. detailed discussion contributing tidyverse packages, please see development contributing guide code review principles.","code":""},{"path":"https://lcbc-uio.github.io/galamm/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to galamm","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"https://lcbc-uio.github.io/galamm/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to galamm","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed). See guide create great issue advice.","code":""},{"path":"https://lcbc-uio.github.io/galamm/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to galamm","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"LCBC-UiO/galamm\", fork = TRUE). Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"https://lcbc-uio.github.io/galamm/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to galamm","text":"New code follow tidyverse style guide. can use styler package apply styles, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"https://lcbc-uio.github.io/galamm/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to galamm","text":"Please note galamm project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://lcbc-uio.github.io/galamm/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://lcbc-uio.github.io/galamm/articles/galamm.html","id":"generalized-additive-latent-and-mixed-models","dir":"Articles","previous_headings":"","what":"Generalized Additive Latent and Mixed Models","title":"Introduction","text":"Generalized additive latent mixed models (GALAMMs) (Sørensen, Fjell, Walhovd 2023) extension generalized linear latent mixed models (GLLAMMs) (Rabe-Hesketh, Skrondal, Pickles 2004; Skrondal Rabe-Hesketh 2004) allows observed responses latent variables depend smoothly observed variables. Smoothly means relationship assumed follow particular parametric form, e.g., specified linear model. Instead, priori assumption made relationship smooth, model attempts learn relationship data. GALAMM uses smoothing splines obtain , identically generalized additive models (GAMs) (Wood 2017) estimated. GLLAMM framework contains many elements currently implemented galamm package. includes nonparametric random effects large number model families, e.g., censored responses. need , semiparametric estimation, Stata based GLLAMM package likely place go. Conversely, galamm incorporates crossed random effects easily efficiently, hard specify using GLLAMM.","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/galamm.html","id":"response-model","dir":"Articles","previous_headings":"Generalized Additive Latent and Mixed Models","what":"Response Model","title":"Introduction","text":"GALAMMs specified using three building blocks. First, \\(n\\) responses \\(y_{1}, \\dots, y_{n}\\) assumed independently distributed according exponential family density \\[ f\\left(y | \\theta, \\phi\\right) = \\exp \\left( \\frac{y\\theta(\\mu) - b\\left(\\theta(\\mu)\\right)}{\\phi} + c\\left(y, \\phi\\right) \\right) \\] \\(\\mu = g^{-1}(\\nu)\\) mean, \\(g^{-1}(\\cdot)\\) inverse link function \\(g(\\cdot)\\), \\(\\nu\\) “nonlinear predictor”, \\(\\phi\\) dispersion parameter, \\(b(\\cdot)\\) \\(c(\\cdot)\\) known functions. contrast assumed, e.g., lme4 (Bates et al. 2015), functions \\(b(\\cdot)\\), \\(c(\\cdot)\\), \\(g(\\cdot)\\) allowed vary observations. , observations can come different members exponential family. vignette models mixed response types describes detail. Using canonical link functions, response model simplifies \\[ f\\left(y | \\nu, \\phi\\right) = \\exp \\left( \\frac{y\\nu - b\\left(\\nu\\right)}{\\phi} + c\\left(y, \\phi\\right) \\right) \\]","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/galamm.html","id":"nonlinear-predictor","dir":"Articles","previous_headings":"Generalized Additive Latent and Mixed Models","what":"Nonlinear Predictor","title":"Introduction","text":"Next, nonlinear predictor, corresponds measurement model classical structural equation model, defined \\[ \\nu = \\sum_{s=1}^{S} f_{s}\\left(\\mathbf{x}\\right) + \\sum_{l=2}^{L}\\sum_{m=1}^{M_{l}} \\eta_{m}^{(l)} \\mathbf{z}^{(l)}_{m}{}^{'}\\boldsymbol{\\lambda}_{m}^{(l)}, \\] \\(\\mathbf{x}\\) explanatory variables, \\(f_{s}(\\mathbf{x})\\), \\(s=1,\\dots,S\\) smooth functions, \\(\\eta_{m}^{(l)}\\) latent variables varying level \\(l\\), \\(\\boldsymbol{\\lambda}_{m}^{(l)}{}^{T} \\mathbf{z}_{m}^{(l)}\\) weighted sum vector explanatory variables \\(\\mathbf{z}_{m}^{(l)}\\) varying level \\(l\\) parameters \\(\\boldsymbol{\\lambda}_{m}^{(l)}\\). Let \\[\\boldsymbol{\\eta}^{(l)} = [\\eta_{1}^{(l)}, \\dots, \\eta_{M_{l}}^{(l)}]^{T} \\\\mathbb{R}^{M_{l}}\\] vector latent variables level \\(l\\), \\[\\boldsymbol{\\eta} = [\\boldsymbol{\\eta}^{(2)}, \\dots, \\boldsymbol{\\eta}^{(L)}]^{T} \\\\mathbb{R}^{M}\\] vector latent variables belonging given level-2 unit, \\(M = \\sum_{l=2}^{L} M_{l}\\). word “level” used denote grouping level; necessarily hierarchical.","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/galamm.html","id":"structural-model","dir":"Articles","previous_headings":"","what":"Structural Model","title":"Introduction","text":"structural model specifies latent variables related observed variables, given \\[ \\boldsymbol{\\eta} = \\mathbf{B}\\boldsymbol{\\eta} + \\mathbf{h}\\left(\\mathbf{w}\\right) + \\boldsymbol{\\zeta} \\] \\(\\mathbf{B}\\) \\(M \\times M\\) matrix regression coefficients regression among latent variables \\(\\mathbf{w} \\\\mathbb{R}^{Q}\\) vector \\(Q\\) predictors latent variables. \\(\\mathbf{h}(\\mathbf{w}) = [\\mathbf{h}_{2}(\\mathbf{w}), \\dots, \\mathbf{h}_{L}(\\mathbf{w})] \\\\mathbb{R}^{M}\\) vector smooth functions whose components \\(\\mathbf{h}_{l}(\\mathbf{w}) \\\\mathbb{R}^{M_{l}}\\) vectors functions predicting latent variables varying level \\(l\\), depending subset elements \\(\\mathbf{w}\\). \\(\\boldsymbol{\\zeta}\\) vector normally distributed random effects, \\(\\boldsymbol{\\zeta}^{(l)} \\sim N(\\mathbf{0}, \\boldsymbol{\\Psi}^{(l)})\\) \\(l=2,\\dots,L\\), \\(\\boldsymbol{\\Psi}^{(l)} \\\\mathbb{R}^{M_{l} \\times M_{l}}\\) covariance matrix random effects level \\(l\\). Defining \\(M \\times M\\) covariance matrix \\(\\boldsymbol{\\Psi} = \\text{diag}(\\boldsymbol{\\Psi}^{(2)}, \\dots, \\boldsymbol{\\Psi}^{(L)})\\), also \\(\\boldsymbol{\\zeta} \\sim N(\\mathbf{0}, \\boldsymbol{\\Psi})\\).","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/galamm.html","id":"mixed-model-representation","dir":"Articles","previous_headings":"","what":"Mixed Model Representation","title":"Introduction","text":"Sørensen, Fjell, Walhovd (2023) show model specified can transformed GLLAMM, essentially generalized nonlinear mixed model. transformation rather complex, won’t spell , key steps : Converting smooth terms mixed model form. Estimate resulting GLLAMM. Convert back original parametrization. galamm use transformations gamm4 package .","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/galamm.html","id":"maximum-marginal-likelihood-estimation","dir":"Articles","previous_headings":"","what":"Maximum Marginal Likelihood Estimation","title":"Introduction","text":"mixed model representation, nonlinear predictor can written form \\[ \\boldsymbol{\\nu} = \\mathbf{X}(\\boldsymbol{\\lambda}, \\mathbf{B}) \\boldsymbol{\\beta} +  \\mathbf{Z}(\\boldsymbol{\\lambda}, \\mathbf{B}) \\boldsymbol{\\zeta} \\] \\(\\mathbf{X}(\\boldsymbol{\\lambda}, \\mathbf{B})\\) regression matrix fixed effects \\(\\boldsymbol{\\beta}\\) \\(\\mathbf{Z}(\\boldsymbol{\\lambda}, \\mathbf{B})\\) regression matrix random effects \\(\\boldsymbol{\\zeta}\\). contrast generalized linear mixed models, however, matrices general depend factor loadings \\(\\boldsymbol{\\lambda}\\) regression coefficients latent variables \\(\\mathbf{B}\\). parameters need estimated, hence \\(\\mathbf{X}(\\boldsymbol{\\lambda}, \\mathbf{B})\\) \\(\\boldsymbol{\\beta}\\) \\(\\mathbf{Z}(\\boldsymbol{\\lambda}, \\mathbf{B})\\) need updated throughout estimation process.","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/galamm.html","id":"evaluating-the-marginal-likelihood","dir":"Articles","previous_headings":"Maximum Marginal Likelihood Estimation","what":"Evaluating the Marginal Likelihood","title":"Introduction","text":"Plugging nonlinear predictor structural model, obtain joint likelihood model. obtain marginal likelihood integrating random effects, yielding marginal likelihood function form \\[ L\\left(\\boldsymbol{\\beta}, \\boldsymbol{\\Lambda}, \\boldsymbol{\\Gamma}, \\boldsymbol{\\lambda}, \\mathbf{B}, \\boldsymbol{\\phi}\\right) =  \\left(2 \\pi \\phi_{1}\\right)^{-r/2}  \\int_{\\mathbb{R}^{r}} \\exp\\left( g\\left(\\boldsymbol{\\beta}, \\boldsymbol{\\Lambda}, \\boldsymbol{\\Gamma}, \\boldsymbol{\\lambda}, \\mathbf{B}, \\boldsymbol{\\phi}, \\mathbf{u}\\right) \\right) \\text{d} \\mathbf{u} \\] \\(\\mathbf{u}\\) standardized version \\(\\boldsymbol{\\zeta}\\). order evaluate marginal likelihood given set parameter values, use Laplace approximation combined sparse matrix operations, extending Bates et al. (2015)’s algorithm linear mixed models.","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/galamm.html","id":"maximizing-the-marginal-likelihood","dir":"Articles","previous_headings":"Maximum Marginal Likelihood Estimation","what":"Maximizing the Marginal Likelihood","title":"Introduction","text":"obtain maximum marginal likelihood estimates maximizing \\(L\\left(\\boldsymbol{\\beta}, \\boldsymbol{\\Lambda}, \\boldsymbol{\\Gamma}, \\boldsymbol{\\lambda}, \\mathbf{B}, \\boldsymbol{\\phi}\\right)\\), subject possible constraints, e.g., variances non-negative. , use L-BFGS-B algorithm implement stats::optim. predicted values random effects, \\(\\widehat{\\mathbf{u}}\\) obtained posterior modes final estimates.","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/galamm.html","id":"example-models","dir":"Articles","previous_headings":"","what":"Example Models","title":"Introduction","text":"see galamm used practice, take look vignettes describing models different components. Linear mixed models factor structures. Generalized linear mixed models factor structures. Linear mixed models heteroscedastic residuals. Mixed models mixed response types. Generalized additive mixed models factor structures.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/articles/glmm_factor.html","id":"model-with-binomially-distributed-responses","dir":"Articles","previous_headings":"","what":"Model with Binomially Distributed Responses","title":"Generalized Linear Mixed Models with Factor Structures","text":"use simulated dataset PLmixed package example. observations binomial responses representing ability measurement. first lines shown . student identified student id sid, school school id given school variable. student, five item measurements made. assume student’s performance depends students ability well school student attends. outline GALAMMs introductory vignette mind, assume binomial response model logit link, yielding \\(\\)th measurement \\(j\\)th student \\(k\\)th school, \\[ \\text{P}(y_{ijk} = 1 | \\mathbf{x}_{ijk}, \\boldsymbol{\\eta}_{jk}) = \\frac{\\exp(\\nu_{ijk})}{1 + \\exp(\\nu_{ijk})} \\] latent variable vector given \\(\\boldsymbol{\\eta}_{jk} = (\\eta_{j}, \\eta_{jk})^{T}\\), last element effect school \\(j\\)th student attends. nonlinear predictor given \\[ \\nu_{ijk} = \\mathbf{x}_{ijk}^{T} \\boldsymbol{\\beta} + \\mathbf{x}_{ijk}^{T}\\boldsymbol{\\lambda} (\\eta_{j} + \\eta_{jk}) \\] \\(\\mathbf{x}_{ij}\\) vector containing dummy variables items, \\(\\eta_{j}\\) latent variable describing underlying ability student \\(j\\), \\(\\eta_{k}\\) latent variable describing effect school \\(k\\). factor loading \\(\\lambda\\) describes sum two latent variables impacts nonlinear predictor, hence probability correct response. note using common \\(\\lambda\\) two latent variables like necessarily good model, makes introductory example easier follow. extend model later. structural model simply \\[ \\boldsymbol{\\eta}_{jk} = \\boldsymbol{\\zeta}_{jk} \\sim N_{2}(\\mathbf{0}, \\boldsymbol{\\Psi}), \\] \\(N(\\mathbf{0}, \\boldsymbol{\\Psi})\\) denotes bivariate normal distribution mean zero covariance matrix \\(\\boldsymbol{\\Psi}\\). covariance matrix assumed diagonal. confirm item five levels. means \\(\\boldsymbol{\\lambda}\\) vector five elements. identifiability, fix first element \\(\\boldsymbol{\\lambda}\\) one. rest freely estimated. defining following matrix. numeric value implies element fixed, whereas NA implies element unknown, estimated. fit model follows: couple things model formula worth pointing . First part (0 + ability | school / sid) model formula specifies student ability varies students within schools. corresponds term \\(\\mathbf{x}_{ijk}^{T}\\boldsymbol{\\lambda} (\\eta_{j} + \\eta_{jk})\\) mathematical specification model. variable ability part IRTsim dataframe, instead specified argument factor = list(\"ability\"). argument load.var = \"item\" specifies rows dataframe value “item” get element \\(\\boldsymbol{\\lambda}\\), hence defines dummy variable \\(\\mathbf{x}_{ijk}\\). Finally, lambda = list(loading_matrix) provides matrix factor loadings. Note must explicitly add zero (0 + ability | school / sid) avoid random intercept estimated addition effect value “item”; model identified. fixed effect part model formula, simply item, specifies term \\(\\mathbf{x}_{ijk}^{T} \\boldsymbol{\\beta}\\). can start inspecting fitted model: fixef method lets us consider fixed effects: can also get Wald type confidence intervals fixed effects. can similarly extract factor loadings. can find confidence intervals . Currently, Wald type confidence intervals available. aware intervals may poor coverage properties. can also show diagnostic plot, although binomial model like informative. Diagnostic plot binomial model.","code":"library(PLmixed) head(IRTsim) #>     sid school item y #> 1.1   1      1    1 1 #> 1.2   1      1    2 1 #> 1.3   1      1    3 1 #> 1.4   1      1    4 0 #> 1.5   1      1    5 1 #> 2.1   2      1    1 1 IRTsim$item <- factor(IRTsim$item) table(IRTsim$item) #>  #>   1   2   3   4   5  #> 500 500 500 500 500 (loading_matrix <- matrix(c(1, NA, NA, NA, NA), ncol = 1)) #>      [,1] #> [1,]    1 #> [2,]   NA #> [3,]   NA #> [4,]   NA #> [5,]   NA mod <- galamm(   formula = y ~ item + (0 + ability | school / sid),   data = IRTsim,   family = binomial,   load.var = \"item\",   factor = list(\"ability\"),   lambda = list(loading_matrix) ) summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ item + (0 + ability | school/sid) #>    Data: IRTsim #>  #>      AIC      BIC   logLik deviance df.resid  #>   2966.4   3030.5  -1472.2   2372.3     2489  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -2.8884 -0.7335  0.4266  0.6235  3.0410  #>  #> Lambda: #>         ability     SE #> lambda1  1.0000      . #> lambda2  0.7370 0.1456 #> lambda3  0.9351 0.1872 #> lambda4  0.6069 0.1261 #> lambda5  0.5860 0.1163 #>  #> Random effects: #>  Groups     Name    Variance Std.Dev. #>  sid:school ability 1.466    1.211    #>  school     ability 1.300    1.140    #> Number of obs: 2500, groups:  sid:school, 500; school, 26 #>  #> Fixed effects: #>             Estimate Std. Error z value Pr(>|z|) #> (Intercept)   0.5112     0.2617   1.953 0.050777 #> item2         0.3256     0.1791   1.818 0.069068 #> item3        -0.4491     0.1623  -2.768 0.005644 #> item4         0.4930     0.1924   2.562 0.010402 #> item5         0.4585     0.1922   2.385 0.017067 fixef(mod) #> (Intercept)       item2       item3       item4       item5  #>   0.5112006   0.3255941  -0.4491070   0.4929827   0.4584897 confint(mod, parm = \"beta\") #>                    2.5 %     97.5 % #> (Intercept) -0.001727334  1.0241286 #> item2       -0.025430062  0.6766183 #> item3       -0.767138526 -0.1310755 #> item4        0.115869898  0.8700955 #> item5        0.081749228  0.8352303 factor_loadings(mod) #>           ability        SE #> lambda1 1.0000000        NA #> lambda2 0.7370254 0.1455782 #> lambda3 0.9351105 0.1872049 #> lambda4 0.6069065 0.1260943 #> lambda5 0.5859914 0.1162977 confint(mod, parm = \"lambda\") #>             2.5 %    97.5 % #> lambda1 0.4516974 1.0223534 #> lambda2 0.5681956 1.3020254 #> lambda3 0.3597662 0.8540468 #> lambda4 0.3580520 0.8139307 plot(mod)"},{"path":"https://lcbc-uio.github.io/galamm/articles/glmm_factor.html","id":"binomial-model-with-multiple-trials","dir":"Articles","previous_headings":"","what":"Binomial Model with Multiple Trials","title":"Generalized Linear Mixed Models with Factor Structures","text":"now show model studied can extended handle binomially distributed data multiple trials. simulate data computing predictions model fitted , drawing binomial samples multiple trials. binomial models one trial, response specified cbind(successes, failures). utility functions apply model well. simply post summary output .","code":"set.seed(1234) dat <- IRTsim dat$trials <- sample(1:10, nrow(dat), replace = TRUE) dat$y <- rbinom(   n = nrow(dat), size = dat$trials,   prob = predict(mod, type = \"response\") ) head(dat) #>     sid school item y trials #> 1.1   1      1    1 8     10 #> 1.2   1      1    2 6      6 #> 1.3   1      1    3 5      5 #> 1.4   1      1    4 6      9 #> 1.5   1      1    5 3      5 #> 2.1   2      1    1 0      6 galamm_mod_trials <- galamm(   formula = cbind(y, trials - y) ~ item + (0 + ability | school / sid),   data = dat,   family = binomial,   load.var = \"item\",   factor = list(\"ability\"),   lambda = list(loading_matrix) ) summary(galamm_mod_trials) #> GALAMM fit by maximum marginal likelihood. #> Formula: cbind(y, trials - y) ~ item + (0 + ability | school/sid) #>    Data: dat #>  #>      AIC      BIC   logLik deviance df.resid  #>   7018.6   7082.6  -3498.3   2537.4     2489  #>  #> Scaled residuals:  #>    Min     1Q Median     3Q    Max  #> -2.387  1.811  5.116 10.124 42.919  #>  #> Lambda: #>         ability      SE #> lambda1  1.0000       . #> lambda2  0.7040 0.05234 #> lambda3  0.8750 0.06257 #> lambda4  0.5744 0.04613 #> lambda5  0.6076 0.04829 #>  #> Random effects: #>  Groups     Name    Variance Std.Dev. #>  sid:school ability 0.6848   0.8275   #>  school     ability 1.1671   1.0803   #> Number of obs: 2500, groups:  sid:school, 500; school, 26 #>  #> Fixed effects: #>             Estimate Std. Error z value  Pr(>|z|) #> (Intercept)   0.4768    0.22158   2.152 3.142e-02 #> item2         0.3009    0.09257   3.251 1.151e-03 #> item3        -0.5032    0.07100  -7.087 1.371e-12 #> item4         0.3965    0.11423   3.471 5.186e-04 #> item5         0.4823    0.10859   4.442 8.919e-06"},{"path":"https://lcbc-uio.github.io/galamm/articles/glmm_factor.html","id":"model-with-poisson-distributed-responses","dir":"Articles","previous_headings":"","what":"Model with Poisson Distributed Responses","title":"Generalized Linear Mixed Models with Factor Structures","text":"illustrate model counts, consider example Chapter 11.3 Skrondal Rabe-Hesketh (2004). model contain factor loadings, use demonstrate fit GLMMs Poisson distributed responses. can look summary output. case factor loadings return: can look diagnostic plot, case looks much reasonable. Diagnostic plot Poisson model. case can confirm galamm function correctly implemented comparing output lme4::glmer. model like , also best use lme4, factor structures nonlinearities, lme4 longer provides flexibility need. can confirm diagnostic plot values galamm: lme4 diagnostic plot Poisson model. can summary output. might note deviance summary output model fitted lme4 different deviance model fitted galamm. summary output, lme4 shows deviance minus two times log likelihood. contrast, calling deviance function model object fitted glmer gives output galamm. details deviance calculation lme4, see help(deviance.merMod, \"lme4\").","code":"count_mod <- galamm(   formula = y ~ lbas * treat + lage + v4 + (1 | subj),   data = epilep,   family = poisson ) summary(count_mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ lbas * treat + lage + v4 + (1 | subj) #>    Data: epilep #>  #>      AIC      BIC   logLik deviance df.resid  #>   1344.7   1369.0   -665.4    407.0      229  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -3.1918 -0.8456 -0.0917  0.5839  6.6303  #>  #> Random effects: #>  Groups Name        Variance Std.Dev. #>  subj   (Intercept) 0.2516   0.5016   #> Number of obs: 236, groups:  subj, 59 #>  #> Fixed effects: #>             Estimate Std. Error z value  Pr(>|z|) #> (Intercept)   1.7936    0.10468  17.134 8.230e-66 #> lbas          0.8845    0.13096   6.754 1.436e-11 #> treat        -0.3350    0.14775  -2.267 2.339e-02 #> lage          0.4846    0.34658   1.398 1.621e-01 #> v4           -0.1611    0.05458  -2.952 3.161e-03 #> lbas:treat    0.3384    0.20293   1.668 9.541e-02 factor_loadings(count_mod) plot(count_mod) library(lme4) #> Loading required package: Matrix #>  #> Attaching package: 'lme4' #> The following object is masked from 'package:galamm': #>  #>     llikAIC count_mod_lme4 <- glmer(   formula = y ~ lbas * treat + lage + v4 + (1 | subj),   data = epilep,   family = poisson ) plot(count_mod_lme4) summary(count_mod_lme4) #> Generalized linear mixed model fit by maximum likelihood (Laplace Approximation) ['glmerMod'] #>  Family: poisson  ( log ) #> Formula: y ~ lbas * treat + lage + v4 + (1 | subj) #>    Data: epilep #>  #>      AIC      BIC   logLik deviance df.resid  #>   1344.7   1369.0   -665.4   1330.7      229  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -3.1918 -0.8456 -0.0918  0.5837  6.6303  #>  #> Random effects: #>  Groups Name        Variance Std.Dev. #>  subj   (Intercept) 0.2515   0.5015   #> Number of obs: 236, groups:  subj, 59 #>  #> Fixed effects: #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept)   1.7937     0.1045  17.165  < 2e-16 *** #> lbas          0.8844     0.1308   6.764 1.34e-11 *** #> treat        -0.3349     0.1474  -2.272  0.02311 *   #> lage          0.4845     0.3458   1.401  0.16121     #> v4           -0.1611     0.0543  -2.966  0.00301 **  #> lbas:treat    0.3382     0.2025   1.671  0.09479 .   #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Correlation of Fixed Effects: #>            (Intr) lbas   treat  lage   v4     #> lbas       -0.035                             #> treat      -0.708  0.024                      #> lage       -0.092 -0.037  0.099               #> v4          0.015  0.000  0.000  0.000        #> lbas:treat  0.001 -0.654 -0.087  0.252  0.000 deviance(count_mod_lme4) #> [1] 407.0092"},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/articles/latent_observed_interaction.html","id":"linear-mixed-model-with-latent-covariates","dir":"Articles","previous_headings":"","what":"Linear Mixed Model with Latent Covariates","title":"Interactions Between Latent and Observed Covariates","text":"example use simulated latent_covariates dataset, first six rows displayed :","code":"head(latent_covariates) #>   id         type         x            y response #> 1  1 measurement1 0.2655087 -0.530999307        0 #> 2  1 measurement2 0.2655087 -0.911206495        0 #> 3  1     response 0.2655087  0.483055528        1 #> 4  2 measurement1 0.3721239  0.003752663        0 #> 5  2 measurement2 0.3721239  0.220165165        0 #> 6  2     response 0.3721239  0.327782922        1"},{"path":"https://lcbc-uio.github.io/galamm/articles/latent_observed_interaction.html","id":"model-formulation","dir":"Articles","previous_headings":"Linear Mixed Model with Latent Covariates","what":"Model Formulation","title":"Interactions Between Latent and Observed Covariates","text":"response variable y contains measurements latent variable measurements response actually interested modeling, type variable distinguishes responses. case complete observations subject ID, given ID, measurement model can written follows: \\[ \\begin{pmatrix} y_{1} \\\\ y_{2} \\\\ y_{3} \\end{pmatrix} = \\boldsymbol{\\beta}_{0} + \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & x \\end{pmatrix} \\begin{pmatrix} 1 \\\\ \\lambda_{2} \\\\ \\lambda_{3} \\\\ \\lambda_{4} \\end{pmatrix} \\eta + \\begin{pmatrix} 0 \\\\ 0 \\\\ x \\beta \\end{pmatrix} + \\boldsymbol{\\epsilon}. \\] equation \\(\\boldsymbol{\\beta}_{0} \\\\mathbb{R}^{3}\\) vector intercepts, \\(\\eta\\) latent variable, loading latent variable onto first measurement \\(y_{1}\\) fixed 1 identifiability, \\(\\lambda_{2}\\) loading latent variable onto second measurement \\(y_{2}\\), \\(\\lambda_{3}\\) main effect latent variable response interest \\(y_{3}\\), \\(\\beta\\) effect observed covariate \\(x\\) \\(y_{3}\\), \\(\\lambda_{4}\\) interaction effect \\(x\\) \\(\\eta\\) \\(y_{3}\\). assume residuals \\(\\boldsymbol{\\epsilon}\\) independently identically normally distributed; assumption valid simulated case, note since response \\(y_{3}\\) qualitatively different measurements \\(y_{1}\\) \\(y_{2}\\), assumption general hold, heteroscedastic measurement model used, model mixed response types. detailed explanation way formulating latent variable models matrix form refer first four pages Rockwood Jeon (2019). structural model simply \\(\\eta = \\zeta \\sim N(0, \\psi)\\), \\(\\psi\\) variance.","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/latent_observed_interaction.html","id":"model-without-interaction","dir":"Articles","previous_headings":"Linear Mixed Model with Latent Covariates","what":"Model Without Interaction","title":"Interactions Between Latent and Observed Covariates","text":"can instructive start considering model fix \\(\\\\lambda_{4} = 0\\). type model estimated following code: data generating simulations, true values \\(\\lambda_{1}=1\\), \\(\\lambda_{2} = 1.3\\) \\(\\lambda_{3} = -0.3\\). former two well recovered, latter positive, likely due us omitting interaction \\(\\lambda_{4}\\), whose true value 0.2.","code":"lambda <- list(matrix(c(1, NA, NA), ncol = 1))  mod0 <- galamm(   formula = y ~ type + x:response + (0 + loading | id),   data = latent_covariates,   load.var = \"type\",   lambda = lambda,   factor = list(\"loading\") ) summary(mod0) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ type + x:response + (0 + loading | id) #>    Data: latent_covariates #>  #>      AIC      BIC   logLik deviance df.resid  #>    197.5    232.7    -90.8    181.5      592  #>  #> Scaled residuals:  #>      Min       1Q   Median       3Q      Max  #> -2.92130 -0.52315 -0.01058  0.52532  3.01104  #>  #> Lambda: #>         loading       SE #> lambda1  1.0000        . #> lambda2  1.3033 0.013687 #> lambda3 -0.2063 0.008515 #>  #> Random effects: #>  Groups   Name    Variance Std.Dev. #>  id       loading 0.98112  0.9905   #>  Residual         0.01357  0.1165   #> Number of obs: 600, groups:  id, 200 #>  #> Fixed effects: #>                   Estimate Std. Error  t value  Pr(>|t|) #> (Intercept)      -0.010588    0.07052 -0.15014 8.807e-01 #> typemeasurement2 -0.002173    0.02423 -0.08968 9.285e-01 #> typeresponse      0.029353    0.08678  0.33826 7.352e-01 #> x:response        0.470444    0.03093 15.20943 3.062e-52"},{"path":"https://lcbc-uio.github.io/galamm/articles/latent_observed_interaction.html","id":"linear-interaction-between-observed-and-latent-covariates","dir":"Articles","previous_headings":"Linear Mixed Model with Latent Covariates","what":"Linear Interaction Between Observed and Latent Covariates","title":"Interactions Between Latent and Observed Covariates","text":"measurement model can equivalently written \\[ \\begin{pmatrix} y_{1} \\\\ y_{2} \\\\ y_{3} \\end{pmatrix} = \\boldsymbol{\\beta}_{0} + \\begin{pmatrix} 1 \\\\ \\lambda_{2} \\\\ \\lambda_{3} + \\lambda_{4} x \\end{pmatrix} \\eta + \\begin{pmatrix} 0 \\\\ 0 \\\\ x \\beta \\end{pmatrix} + \\boldsymbol{\\epsilon}. \\] way writing shows explicitly factor loadings connected observation. order fit model galamm, must provide formulas terms loading matrix \\[ \\begin{pmatrix} 1 \\\\ \\lambda_{2} \\\\ \\lambda_{3} + \\lambda_{4} x \\end{pmatrix}. \\] specify factor interactions list lists. reason notation need one list hold regression terms loading variable specified load.var. specifies first two rows, covariates, third row, want linear regression \\(x\\) covariate. Next, specify loading matrix without interaction parameter, .e., reuse lambda object specified mod0 . lets us fit model follows: model comparison shows overwhelming evidence favor model, surprising since data simulated. summary also shows bias \\(\\lambda_{3}\\) basically disappeared, -0.318 -0.195, true value -0.3. interaction estimated 0.233, also close true value 0.2. course noted noise level simulated dataset set unrealistically low, let us confirm implementation correct.","code":"factor_interactions <- list(list(~ 1, ~ 1, ~ x)) mod <- galamm(   formula = y ~ type + x:response + (0 + loading | id),   data = latent_covariates,   load.var = \"type\",   lambda = lambda,   factor = list(\"loading\"),   factor_interactions = factor_interactions ) anova(mod, mod0) #> Data: latent_covariates #> Models: #> mod0: y ~ type + x:response + (0 + loading | id) #> mod: y ~ type + x:response + (0 + loading | id) #>      npar    AIC    BIC  logLik deviance Chisq Df Pr(>Chisq)     #> mod0    8 197.52 232.70 -90.761   120.31                         #> mod     9 138.31 177.88 -60.155   120.31 61.21  1  5.129e-15 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ type + x:response + (0 + loading | id) #>    Data: latent_covariates #>  #>      AIC      BIC   logLik deviance df.resid  #>    138.3    177.9    -60.2    120.3      591  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -2.2033 -0.5251 -0.0273  0.5146  3.5029  #>  #> Lambda: #>           loading      SE #> lambda1    1.0000       . #> lambda2    1.3034 0.01268 #> lambda3   -0.3183 0.01604 #> lambda4_x  0.2331 0.02873 #>  #> Random effects: #>  Groups   Name    Variance Std.Dev. #>  id       loading 0.98175  0.9908   #>  Residual         0.01164  0.1079   #> Number of obs: 600, groups:  id, 200 #>  #> Fixed effects: #>                   Estimate Std. Error  t value  Pr(>|t|) #> (Intercept)      -0.010589    0.07048 -0.15024 8.806e-01 #> typemeasurement2 -0.002173    0.02384 -0.09116 9.274e-01 #> typeresponse      0.034005    0.09417  0.36109 7.180e-01 #> x:response        0.462507    0.03300 14.01556 1.252e-44"},{"path":"https://lcbc-uio.github.io/galamm/articles/latent_observed_interaction.html","id":"interaction-between-latent-covariate-and-a-quadratic-term","dir":"Articles","previous_headings":"Linear Mixed Model with Latent Covariates","what":"Interaction Between Latent Covariate and a Quadratic Term","title":"Interactions Between Latent and Observed Covariates","text":"can also try add interactions \\(x^{2}\\) \\(\\eta\\). first update formula factor_interactions: fit model : can seen, coefficient squared interaction significantly different zero.","code":"factor_interactions <- list(list(~ 1, ~ 1, ~ x + I(x^2))) mod2 <- galamm(   formula = y ~ type + x:response + (0 + loading | id),   data = latent_covariates,   load.var = \"type\",   lambda = lambda,   factor = list(\"loading\"),   factor_interactions = factor_interactions ) summary(mod2) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ type + x:response + (0 + loading | id) #>    Data: latent_covariates #>  #>      AIC      BIC   logLik deviance df.resid  #>    140.3    184.2    -60.1    120.3      590  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -2.2012 -0.5212 -0.0228  0.5173  3.4968  #>  #> Lambda: #>                 loading      SE #> lambda1         1.00000       . #> lambda2         1.30340 0.01267 #> lambda3        -0.31418 0.02446 #> lambda4_x       0.20906 0.11252 #> lambda5_I(x^2)  0.02453 0.11097 #>  #> Random effects: #>  Groups   Name    Variance Std.Dev. #>  id       loading 0.98175  0.9908   #>  Residual         0.01164  0.1079   #> Number of obs: 600, groups:  id, 200 #>  #> Fixed effects: #>                   Estimate Std. Error  t value  Pr(>|t|) #> (Intercept)      -0.009919    0.07054 -0.14062 8.882e-01 #> typemeasurement2 -0.001969    0.02385 -0.08256 9.342e-01 #> typeresponse      0.033289    0.09426  0.35316 7.240e-01 #> x:response        0.462228    0.03305 13.98397 1.953e-44"},{"path":"https://lcbc-uio.github.io/galamm/articles/latent_observed_interaction.html","id":"models-with-additional-random-effects","dir":"Articles","previous_headings":"","what":"Models with Additional Random Effects","title":"Interactions Between Latent and Observed Covariates","text":"also straightforward include additional random effects models containing interactions latent observed covariates. dataset latent_covariates_long similar latent_covariates used , six repeated measurements response subject. first ten rows dataset shown . data add random intercept response terms, addition terms used . start resetting interaction models linear term: Next fit model using galamm. difference notice added (0 + response | id) formula. implies observations responses, response = 1, random intercept per subject. summary, see also case factor loadings well recovered.","code":"head(latent_covariates_long, 10) #>    id         type         x            y response #> 1   1 measurement1 0.2655087 -0.530999307        0 #> 2   1 measurement2 0.2655087 -0.911206495        0 #> 3   1     response 0.2655087  0.250414575        1 #> 4   1     response 0.2655087  0.702355328        1 #> 5   2 measurement1 0.3721239  0.003752663        0 #> 6   2 measurement2 0.3721239  0.220165165        0 #> 7   2     response 0.3721239  0.337374818        1 #> 8   2     response 0.3721239  0.315766396        1 #> 9   3 measurement1 0.5728534 -0.902625075        0 #> 10  3 measurement2 0.5728534 -1.127476052        0 factor_interactions <- list(list(~ 1, ~ 1, ~ x)) mod <- galamm(   formula = y ~ type + x:response + (0 + loading | id) + (0 + response | id),   data = latent_covariates_long,   load.var = \"type\",   lambda = lambda,   factor = list(\"loading\"),   factor_interactions = factor_interactions ) summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ type + x:response + (0 + loading | id) + (0 + response |      id) #>    Data: latent_covariates_long #>  #>      AIC      BIC   logLik deviance df.resid  #>    150.6    197.5    -65.3    130.6      790  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -3.3804 -0.5291 -0.0199  0.5126  3.5849  #>  #> Lambda: #>           loading      SE #> lambda1    1.0000       . #> lambda2    1.3036 0.01672 #> lambda3   -0.3279 0.01539 #> lambda4_x  0.2415 0.02730 #>  #> Random effects: #>  Groups   Name     Variance Std.Dev. #>  id       loading  0.97824  0.9891   #>  id.1     response 0.00000  0.0000   #>  Residual          0.02018  0.1420   #> Number of obs: 800, groups:  id, 200 #>  #> Fixed effects: #>                   Estimate Std. Error  t value  Pr(>|t|) #> (Intercept)      -0.010585    0.07065 -0.14981 8.809e-01 #> typemeasurement2 -0.002171    0.02555 -0.08498 9.323e-01 #> typeresponse      0.033712    0.09473  0.35590 7.219e-01 #> x:response        0.474623    0.03178 14.93242 2.028e-50"},{"path":"https://lcbc-uio.github.io/galamm/articles/latent_observed_interaction.html","id":"model-with-smooth-terms","dir":"Articles","previous_headings":"","what":"Model with Smooth Terms","title":"Interactions Between Latent and Observed Covariates","text":"can also include smooth terms models containing interactions latent observed variables. example, replace linear term x:response smooth term s(x, = response). Since smooth term also includes main effect response, corresponds intercept response observations, must remove type term instead insert two dummy variables, one measurement. first create dummy variables: fit model: summary output suggest factor loadings well recovered. can also plot smooth term, linear. , case smooth term necessary. can also see zero variance estimate random effect named s(x):response summary , mean smoothing parameter term infinite, hence smooth term exactly linear. Smooth term model interaction latent observed covariates.","code":"dat <- latent_covariates dat$m1 <- as.numeric(dat$type == \"measurement1\") dat$m2 <- as.numeric(dat$type == \"measurement2\") mod <- galamm(   formula = y ~ 0 + m1 + m2 + s(x, by = response) + (0 + loading | id),   data = dat,   load.var = \"type\",   lambda = lambda,   factor = list(\"loading\"),   factor_interactions = factor_interactions ) summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ 0 + m1 + m2 + s(x, by = response) + (0 + loading | id) #>    Data: dat #>  #>      AIC      BIC   logLik deviance df.resid  #>    140.3    184.3    -60.2    120.3      590  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -2.2032 -0.5251 -0.0273  0.5146  3.5029  #>  #> Lambda: #>           loading      SE #> lambda1    1.0000       . #> lambda2    1.3034 0.01268 #> lambda3   -0.3183 0.01604 #> lambda4_x  0.2331 0.02873 #>  #> Random effects: #>  Groups   Name          Variance Std.Dev. #>  id       loading       0.98175  0.9908   #>  Xr       s(x):response 0.00000  0.0000   #>  Residual               0.01164  0.1079   #> Number of obs: 600, groups:  id, 200; Xr, 8 #>  #> Fixed effects: #>                  Estimate Std. Error  t value  Pr(>|t|) #> m1               -0.01059   0.070477  -0.1503 8.805e-01 #> m2               -0.01276   0.091638  -0.1393 8.892e-01 #> s(x):responseFx1 -0.12412   0.008856 -14.0155 1.252e-44 #> s(x):responseFx2 -0.26284   0.015809 -16.6255 4.558e-62 #>  #> Approximate significance of smooth terms: #>               edf Ref.df     F p-value #> s(x):response   2      2 417.2  <2e-16 plot_smooth(mod)"},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/articles/lmm_factor.html","id":"crossed-random-effects-model-with-persistence-parameters","dir":"Articles","previous_headings":"","what":"Crossed Random Effects Model with Persistence Parameters","title":"Linear Mixed Models with Factor Structures","text":"example comes Section 3.1 Jeon Rabe-Hesketh (2012), whose model based McCaffrey et al. (2004). dataset KYPSsim comes PLmixed simulated version Korea Youth Panel Survey (KYPS) data. Student self esteem (variable esteem) assessed four timepoints, first two student attended middle school, second two student attended high school. variables mid hid represent middle school high school given student attended, sid student identifier. variable time indicates given timepoint. use discrete time model, hence convert time variable factor. Since students attending given middle school necessarily attend high school, model crossed random effects. use model Jeon Rabe-Hesketh (2012), whose measurement part can formulated \\[ y_{tsmh} = \\beta_{0} + \\sum_{t'=2}^{4} d_{tt'}\\beta_{t'} + \\mathbf{d}_{t}^{T} \\left(\\boldsymbol{\\lambda}_{m}  \\eta_{m} + \\boldsymbol{\\lambda}_{h}  \\eta_{h}\\right) + \\eta_{s} + \\epsilon_{tsmh}, \\] \\(\\mathbf{d}_{t} = (d_{t1},d_{t2},d_{t3},d_{t4})^{T}\\) vector whose \\(t\\)th element equals one elements equal zero. \\(\\beta_{0}\\) intercept, \\(\\beta_{2}\\), \\(\\beta_{3}\\), \\(\\beta_{4}\\) effects timepoints 2, 3, 4. \\(\\eta_{m}\\) \\(\\eta_{h}\\) “teacher effects” middle school \\(m\\) high school \\(s\\), respectively, \\(\\eta_{s}\\) latent level student \\(s\\), \\(\\epsilon_{tsmh}\\) residual term. \\(\\boldsymbol{\\lambda}_{m}\\) \\(\\boldsymbol{\\lambda}_{h}\\) factor loadings (called “persistence parameters” McCaffrey et al. (2004) Jeon Rabe-Hesketh (2012)) specifying teacher effects middle school high school impact self esteem measurement. Since students attend high school middle school, measurements self esteem middle school assumed affected high school, hence first two elements \\(\\boldsymbol{\\lambda}_{h}\\) set zero. first nonzero element set zero identifiability, \\(\\boldsymbol{\\lambda}_{h} = (0, 0, 1, \\lambda_{h4})^{T}\\). Conversely, allow middle school effect measurements high school, \\(\\boldsymbol{\\lambda}_{m} = (1, \\lambda_{m2}, \\lambda_{m3}, \\lambda_{m4})^{T}\\), first element set zero identifiability. residuals assumed normally distributed, \\(\\epsilon_{tsmh} \\sim N(0, \\phi)\\). Written four timepoints, model becomes \\[ \\begin{aligned} y_{1smh} &= \\beta_{0} +  \\eta_{m} + \\eta_{s} + \\epsilon_{1smh} \\\\ y_{2smh} &= \\beta_{0} + \\beta_{2} + \\lambda_{m2}  \\eta_{m} + \\eta_{s} + \\epsilon_{2smh} \\\\ y_{3smh} &= \\beta_{0} + \\beta_{3} + \\lambda_{m3}  \\eta_{m} +  \\eta_{h} + \\eta_{s} + \\epsilon_{3smh} \\\\ y_{4smh} &= \\beta_{0} + \\beta_{4} + \\lambda_{m4}  \\eta_{m} + \\lambda_{h4}  \\eta_{h} + \\eta_{s} + \\epsilon_{4smh} \\end{aligned} \\] structural model simply \\[ \\begin{pmatrix} \\eta_{m} \\\\ \\eta_{h} \\\\ \\eta_{s} \\end{pmatrix} = \\begin{pmatrix} \\zeta_{m} \\\\ \\zeta_{h} \\\\ \\zeta_{s} \\end{pmatrix} \\sim N_{3}\\left(\\mathbf{0}, \\begin{pmatrix} \\psi_{m} & 0 & 0 \\\\ 0 & \\psi_{h} & 0 \\\\ 0 & 0 & \\psi_{s} \\end{pmatrix} \\right), \\] \\(N_{3}(, b)\\) denotes trivariate normal distribution mean \\(\\) covariance \\(b\\). order fit model galamm, use syntax PLmixed, start defining loading matrix. first column contains \\(\\boldsymbol{\\lambda}_{m}\\) second column contains \\(\\boldsymbol{\\lambda}_{h}\\). Numerical values matrix means entry fixed given value, whereas NA means value unknown, estimated. enclose matrix list, potentially can multiple matrices, list element. connect loading matrix variables dataframe following list factors. Since list loading matrices single element, also list factors single element, one character vector column loading matrix. Finally, define loading variable. variable connecting rows dataframe rows loading matrices. case, value time, corresponding row loading matrix multiplied latent variables \\(\\eta_{m}\\) \\(\\eta_{h}\\), set follows: model formula specified use lme4 syntax random effects. example, term (0 + ms | mid) corresponds \\(\\lambda_{mt}\\eta_{m}\\), | mid specifies \\(\\eta_{m}\\) unique value unique mid. Since \"ms\" can found factors defined , term treated specially, making sure latent variable multiplied factor loading corresponding \"ms\" particular row. contrast, latent variable students \\(\\eta_{s}\\) simple random intercept, hence term (1 | sid) suffices. fit model using galamm following call. model fit PLmixed using following call exactly arguments galamm. reader encouraged try, confirm results essentially equivalent, won’t run vignette takes 5-10 minutes. Using galamm’s summary method, can study model output. can look factor loadings specifically using factor_loadings function. Perhaps surprisingly, middle school teacher effects low impact self esteem student attends high school, can seen last two rows “ms” column close zero. diagnostic plot residuals versus predicted values also looks acceptable, although seems slight upward trend. Diagnostic plot linear mixed model factor structures. can also compare estimated model model constrained factor loadings. particular, assume teacher effect middle school effect self esteem measured high school, setting last two elements \\(\\boldsymbol{\\lambda}_{m}\\) zero. following loading matrix. assume factor loadings timepoints 1 2 middle school timepoints 3 4 high schools identical, practice lead linear mixed model factors. One way estimating model define new loading matrix: Equivalently, create dummy variables timepoints: formulation, don’t need specify factor, load.var, lambda arguments. can compare four models using anova member function. Reassuringly, two ways formulating last model give identical results. Furthermore, simplest model seems preferred two complex models simulated dataset.","code":"head(KYPSsim) #>   mid hid sid time   esteem #> 1   1   1   1    1 2.759234 #> 2   1   1   1    2 2.980368 #> 3   1   1   1    3 3.130784 #> 4   1   1   1    4 3.310306 #> 5   2   1   2    1 2.924520 #> 6   2   1   2    2 2.997440 KYPSsim$time <- factor(KYPSsim$time) levels(KYPSsim$time) #> [1] \"1\" \"2\" \"3\" \"4\" (loading_matrix <- list(rbind(   c(1, 0),   c(NA, 0),   c(NA, 1),   c(NA, NA) ))) #> [[1]] #>      [,1] [,2] #> [1,]    1    0 #> [2,]   NA    0 #> [3,]   NA    1 #> [4,]   NA   NA factors <- list(c(\"ms\", \"hs\")) load.var <- \"time\" form <- esteem ~ time + (0 + ms | mid) + (0 + hs | hid) + (1 | sid) mod <- galamm(   formula = form,   data = KYPSsim,   factor = factors,   load.var = load.var,   lambda = loading_matrix ) kyps_plmixed <- PLmixed(   formula = form,   data = KYPSsim,   factor = factors,   load.var = load.var,   lambda = loading_matrix ) summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: form #>    Data: KYPSsim #>  #>      AIC      BIC   logLik deviance df.resid  #>  19388.0  19476.2  -9682.0  19364.0    11482  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -3.7952 -0.5945  0.0028  0.6049  3.5753  #>  #> Lambda: #>              ms     SE    hs    SE #> lambda1 1.00000      .     .     . #> lambda2 0.87509 0.1421     .     . #> lambda3 0.04432 0.1496 1.000     . #> lambda4 0.02094 0.1543 1.502 0.504 #>  #> Random effects: #>  Groups   Name        Variance Std.Dev. #>  sid      (Intercept) 0.151749 0.38955  #>  hid      hs          0.005253 0.07248  #>  mid      ms          0.010695 0.10342  #>  Residual             0.222511 0.47171  #> Number of obs: 11494, groups:  sid, 2924; hid, 860; mid, 104 #>  #> Fixed effects: #>             Estimate Std. Error t value  Pr(>|t|) #> (Intercept)   3.1479    0.01524 206.619 0.000e+00 #> time2         0.1184    0.01253   9.451 3.361e-21 #> time3         0.1534    0.01607   9.547 1.339e-21 #> time4         0.1924    0.01675  11.489 1.496e-30 factor_loadings(mod) #>                 ms        SE       hs        SE #> lambda1 1.00000000        NA 0.000000        NA #> lambda2 0.87509310 0.1421073 0.000000        NA #> lambda3 0.04431740 0.1495679 1.000000        NA #> lambda4 0.02093663 0.1542824 1.501574 0.5040217 plot(mod) (loading_matrix_constr1 <- list(rbind(   c(1, 0),   c(NA, 0),   c(0, 1),   c(0, NA) ))) #> [[1]] #>      [,1] [,2] #> [1,]    1    0 #> [2,]   NA    0 #> [3,]    0    1 #> [4,]    0   NA mod_constr1 <- galamm(   formula = form,   data = KYPSsim,   factor = factors,   load.var = load.var,   lambda = loading_matrix_constr1 ) (loading_matrix_constr2 <- list(rbind(   c(1, 0),   c(1, 0),   c(0, 1),   c(0, 1) ))) #> [[1]] #>      [,1] [,2] #> [1,]    1    0 #> [2,]    1    0 #> [3,]    0    1 #> [4,]    0    1 mod_constr2 <- galamm(   formula = form,   data = KYPSsim,   factor = factors,   load.var = load.var,   lambda = loading_matrix_constr2 ) KYPSsim$time12 <- as.integer(KYPSsim$time %in% 1:2) KYPSsim$time34 <- as.integer(KYPSsim$time %in% 3:4) head(KYPSsim) #>   mid hid sid time   esteem time12 time34 #> 1   1   1   1    1 2.759234      1      0 #> 2   1   1   1    2 2.980368      1      0 #> 3   1   1   1    3 3.130784      0      1 #> 4   1   1   1    4 3.310306      0      1 #> 5   2   1   2    1 2.924520      1      0 #> 6   2   1   2    2 2.997440      1      0 mod_constr2b <- galamm(   formula = esteem ~ time + (0 + time12 | mid) + (0 + time34 | hid) + (1 | sid),   data = KYPSsim ) anova(   mod, mod_constr1, mod_constr2,   mod_constr2b ) #> Data: KYPSsim #> Models: #> mod_constr2: form #> mod_constr2b: esteem ~ time + (0 + time12 | mid) + (0 + time34 | hid) + (1 | sid) #> mod_constr1: form #> mod: form #>              npar   AIC   BIC  logLik deviance   Chisq Df Pr(>Chisq)    #> mod_constr2     8 19394 19452 -9688.9    19364                          #> mod_constr2b    8 19394 19452 -9688.9    19364  0.0000  0               #> mod_constr1    10 19397 19471 -9688.5    19364  0.6661  2   0.716735    #> mod            12 19388 19476 -9682.0    19364 13.1070  2   0.001425 ** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"},{"path":"https://lcbc-uio.github.io/galamm/articles/lmm_factor.html","id":"multi-trait-multi-rater-model","dir":"Articles","previous_headings":"","what":"Multi-Trait Multi-Rater Model","title":"Linear Mixed Models with Factor Structures","text":"next consider model based example 1 Rockwood Jeon (2019), uses dataset JUDGEsim PLmixed, simulated mimic data used Koch et al. (2016). refer Rockwood Jeon (2019) details, merely present model estimate using galamm. Note however although fit galamm identical presented Rockwood Jeon (2019), estimated factor loadings appear differ table bottom page 298 Rockwood Jeon (2019), due error way matrix factor loadings presented PLmixed versions <= 0.1.6. issue fixed PLmixed version 0.1.7 (Nicholas Rockwood, personal communication, August 2023). data contains ratings two traits students, traits rated students teachers. Initially, need convert item variable factor. first ten rows dataset follows: grouping factors data class (variable class), student (variable stu) teacher (variable tch). teachers’ ratings first trait given items 1-3, students’ rating trait given items 7-9. second trait, items 4-6 10-12, respectively. Looking frequency table, see observations items 1-6. happens single teacher general rate one student, whereas single student rate . matrix-vector format, measurement model (equation 16 Rockwood Jeon (2019)) \\[ \\begin{pmatrix} y_{1tsc} \\\\ \\vdots \\\\ y_{12tsc} \\\\ \\end{pmatrix} = \\begin{pmatrix} \\beta_{1} \\\\ \\vdots \\\\ \\beta_{12} \\end{pmatrix} + \\begin{pmatrix} 1 & 0 & 1 & 0 & 0 & 0 & 1\\\\ \\lambda_{21} & 0 & \\lambda_{23} & 0 & 0 & 0 & 1 \\\\ \\lambda_{31} & 0 & \\lambda_{33} & 0 & 0 & 0 & 1\\\\ 0 & 1 & 0 & 1 & 0 & 0 & 1 \\\\ 0 & \\lambda_{52} & 0 & \\lambda_{54} & 0 & 0 & 1 \\\\ 0 & \\lambda_{62} & 0 & \\lambda_{64} & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 1 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & \\lambda_{85} & 0 & 1 \\\\ 0 & 0 & 0 & 0 & \\lambda_{95} & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & 1 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & \\lambda_{11,6} & 1 \\\\ 0 & 0 & 0 & 0 & 0 & \\lambda_{12,6} & 1 \\\\ \\end{pmatrix} \\begin{pmatrix} \\eta_{1t}^{(t)} \\\\ \\eta_{2t}^{(t)} \\\\ \\eta_{3s}^{(s)} \\\\ \\eta_{4s}^{(s)} \\\\ \\eta_{5s}^{(s)} \\\\ \\eta_{6s}^{(s)} \\\\ \\eta_{7c}^{(c)} \\\\ \\end{pmatrix} + \\boldsymbol{\\epsilon}_{tsc} \\] brief, \\(\\eta_{1t}^{(t)}\\) \\(\\eta_{2t}^{(t)}\\) teacher effects, \\(\\eta_{3s}^{(s)}\\) \\(\\eta_{4s}^{(s)}\\) teacher’s perception students trait, \\(\\eta_{5s}^{(s)}\\) \\(\\eta_{6s}^{(s)}\\) students’ perception trait, \\(\\eta_{7c}^{(c)}\\) classroom effect. factor loadings “regression coefficients” regressing observed items onto latent traits. subscripts \\(t\\), \\(s\\), \\(c\\) indicate teacher, student, class, respectively. structural model simply \\[ \\begin{pmatrix} \\eta_{1t}^{(t)} \\\\ \\eta_{2t}^{(t)} \\\\ \\eta_{3s}^{(s)} \\\\ \\eta_{4s}^{(s)} \\\\ \\eta_{5s}^{(s)} \\\\ \\eta_{6s}^{(s)} \\\\ \\eta_{7c}^{(c)} \\\\ \\end{pmatrix} = \\begin{pmatrix} \\zeta_{1t}^{(t)} \\\\ \\zeta_{2t}^{(t)} \\\\ \\zeta_{3s}^{(s)} \\\\ \\zeta_{4s}^{(s)} \\\\ \\zeta_{5s}^{(s)} \\\\ \\zeta_{6s}^{(s)} \\\\ \\zeta_{7c}^{(c)} \\\\ \\end{pmatrix} \\] \\[ \\begin{pmatrix} \\zeta_{1t}^{(t)} \\\\ \\zeta_{2t}^{(t)} \\\\ \\end{pmatrix} \\sim N_{2}(\\mathbf{0}, \\boldsymbol{\\Psi}^{(t)}), \\] \\[ \\begin{pmatrix} \\zeta_{3s}^{(s)} \\\\ \\zeta_{4s}^{(s)} \\\\ \\zeta_{5s}^{(s)} \\\\ \\zeta_{6s}^{(s)} \\\\ \\end{pmatrix} \\sim N_{4}(\\mathbf{0}, \\boldsymbol{\\Psi}^{(s)}), \\] \\[ \\begin{pmatrix} \\zeta_{7c}^{(c)} \\\\ \\end{pmatrix} \\sim N_{1}(0, \\psi^{(c)}), \\] \\[ \\epsilon_{tsc} \\sim N_{1}(0, \\phi). \\] specify loading matrix follows. comparison mathematical model formulation just , note don’t need add last column ones, since column contains parameters estimated. Next, specify factors order appear columns loading matrix. can choose whichever names like factors, except names existing variables dataset, must make sure match names used formula. formula defined follows, placed terms order appear mathematical model matrix-vector form specified . Using PLmixed, estimated model follows, confirm results galamm. get identical results using galamm less five minutes.","code":"JUDGEsim$item <- factor(JUDGEsim$item) head(JUDGEsim, 10) #>    item method trait stu class tch response #> 1     1      1     1   1     1   1 2.509475 #> 2     1      1     1   1     1   2 3.246730 #> 3     1      1     1   1     1   3 2.846695 #> 4     1      1     1   1     1   4 2.290954 #> 5     1      1     1   1     1   5 2.794368 #> 6     1      1     1   1     1   6 2.849511 #> 7     1      1     1   1     1   7 2.255039 #> 8     1      1     1   2     1   1 2.676437 #> 9     1      1     1   2     1   2 2.923184 #> 10    1      1     1   2     1   3 2.778979 table(JUDGEsim$item) #>  #>    1    2    3    4    5    6    7    8    9   10   11   12  #> 7828 7828 7828 7828 7828 7828 1249 1249 1249 1249 1249 1249 (loading_matrix <- list(rbind(   c(1, 0, 1, 0, 0, 0),   c(NA, 0, NA, 0, 0, 0),   c(NA, 0, NA, 0, 0, 0),   c(0, 1, 0, 1, 0, 0),   c(0, NA, 0, NA, 0, 0),   c(0, NA, 0, NA, 0, 0),   c(0, 0, 0, 0, 1, 0),   c(0, 0, 0, 0, NA, 0),   c(0, 0, 0, 0, NA, 0),   c(0, 0, 0, 0, 0, 1),   c(0, 0, 0, 0, 0, NA),   c(0, 0, 0, 0, 0, NA) ))) #> [[1]] #>       [,1] [,2] [,3] [,4] [,5] [,6] #>  [1,]    1    0    1    0    0    0 #>  [2,]   NA    0   NA    0    0    0 #>  [3,]   NA    0   NA    0    0    0 #>  [4,]    0    1    0    1    0    0 #>  [5,]    0   NA    0   NA    0    0 #>  [6,]    0   NA    0   NA    0    0 #>  [7,]    0    0    0    0    1    0 #>  [8,]    0    0    0    0   NA    0 #>  [9,]    0    0    0    0   NA    0 #> [10,]    0    0    0    0    0    1 #> [11,]    0    0    0    0    0   NA #> [12,]    0    0    0    0    0   NA factors <- list(c(   \"teacher1\", \"teacher2\", \"trait1.t\",   \"trait2.t\", \"trait1.s\", \"trait2.s\" )) form <- response ~ 0 + item + (0 + teacher1 + teacher2 | tch) +   (0 + trait1.t + trait2.t + trait1.s + trait2.s | stu) +   (1 | class) judge_plmixed <- PLmixed(   formula = form,   data = JUDGEsim,   lambda = loading_matrix,   load.var = \"item\",   factor = factors ) judge_galamm <- galamm(   formula = form,   data = JUDGEsim,   lambda = loading_matrix,   load.var = \"item\",   factor = factors ) summary(judge_galamm) #> GALAMM fit by maximum marginal likelihood. #> Formula: form #>    Data: JUDGEsim #>  #>      AIC      BIC   logLik deviance df.resid  #> 113184.6 113531.9 -56553.3 113106.6    54423  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -3.8407 -0.6439  0.0017  0.6474  3.9799  #>  #> Lambda: #>          teacher1      SE teacher2      SE trait1.t      SE trait2.t      SE trait1.s      SE trait2.s      SE #> lambda1    1.0000       .        .       .    1.000       .        .       .        .       .        .       . #> lambda2    1.1278 0.03584        .       .    1.092 0.02172        .       .        .       .        .       . #> lambda3    0.9986 0.03345        .       .    1.066 0.02144        .       .        .       .        .       . #> lambda4         .       .   1.0000       .        .       .   1.0000       .        .       .        .       . #> lambda5         .       .   0.9725 0.03036        .       .   1.0536 0.02576        .       .        .       . #> lambda6         .       .   1.2191 0.03436        .       .   0.9581 0.02460        .       .        .       . #> lambda7         .       .        .       .        .       .        .       .    1.000       .        .       . #> lambda8         .       .        .       .        .       .        .       .    1.322 0.06109        .       . #> lambda9         .       .        .       .        .       .        .       .    1.145 0.05633        .       . #> lambda10        .       .        .       .        .       .        .       .        .       .    1.000       . #> lambda11        .       .        .       .        .       .        .       .        .       .    0.874 0.04417 #> lambda12        .       .        .       .        .       .        .       .        .       .    1.096 0.04874 #>  #> Random effects: #>  Groups   Name        Variance Std.Dev. Corr           #>  stu      trait1.t    0.24025  0.4902                  #>           trait2.t    0.16872  0.4108   0.86           #>           trait1.s    0.29588  0.5439   0.46 0.40      #>           trait2.s    0.37690  0.6139   0.20 0.30 0.40 #>  tch      teacher1    0.09704  0.3115                  #>           teacher2    0.11321  0.3365   0.44           #>  class    (Intercept) 0.00000  0.0000                  #>  Residual             0.39044  0.6249                  #> Number of obs: 54462, groups:  stu, 1249; tch, 390; class, 125 #>  #> Fixed effects: #>        Estimate Std. Error t value Pr(>|t|) #> item1     3.399    0.02270  149.72        0 #> item2     3.363    0.02502  134.42        0 #> item3     3.362    0.02329  144.38        0 #> item4     2.820    0.02226  126.65        0 #> item5     2.939    0.02225  132.08        0 #> item6     2.877    0.02512  114.53        0 #> item7     3.426    0.02344  146.16        0 #> item8     3.552    0.02696  131.77        0 #> item9     3.597    0.02496  144.11        0 #> item10    2.334    0.02479   94.17        0 #> item11    2.909    0.02330  124.83        0 #> item12    2.470    0.02599   95.07        0"},{"path":"https://lcbc-uio.github.io/galamm/articles/lmm_factor.html","id":"model-with-a-product-of-factor-loadings","dir":"Articles","previous_headings":"","what":"Model with a Product of Factor Loadings","title":"Linear Mixed Models with Factor Structures","text":"Finally, Example 2, Rockwood Jeon (2019) consider model contains products factor loadings. moment, model estimated using galamm, although work adding future.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/articles/lmm_heteroscedastic.html","id":"group-wise-heteroscedasticity","dir":"Articles","previous_headings":"","what":"Group-Wise Heteroscedasticity","title":"Heteroscedastic Linear Mixed Models","text":"package includes simulated dataset hsced, residual variance varies items. specify error structure using additional formula object, ~ (1 | item), specifying different constraint term included per item. output shows item 2, residual variance twice item 1. can confirm lme function nlme package gives result. reports multiplies standard deviation scale, since \\(1.412369^2 = 1.995\\), results identical. diagnostic plot also looks good. Diagnostic plot heteroscedastic model. can compare model one homoscedastic residuals. Reassuringly, correct model chosen simple simulated case.","code":"head(hsced) #>   id tp item         x          y #> 1  1  1    1 0.7448212  0.1608286 #> 2  1  1    2 0.7109629  2.2947255 #> 3  1  2    1 0.9507326 -0.4731834 #> 4  1  2    2 0.4205776  1.1280379 #> 5  1  3    1 0.1045820 -0.5129498 #> 6  1  3    2 0.3872984  1.0515916 mod <- galamm(   formula = y ~ x + (1 | id),   weights = ~ (1 | item),   data = hsced ) summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ x + (1 | id) #>    Data: hsced #> Weights: ~(1 | item) #>  #>      AIC      BIC   logLik deviance df.resid  #>   4126.3   4151.7  -2058.1   4116.3     1195  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -5.6545 -0.7105  0.0286  0.6827  4.3261  #>  #> Random effects: #>  Groups   Name        Variance Std.Dev. #>  id       (Intercept) 0.9880   0.9940   #>  Residual             0.9597   0.9796   #> Number of obs: 1200, groups:  id, 200 #>  #> Variance function: #>     1     2  #> 1.000 1.995  #>  #> Fixed effects: #>             Estimate Std. Error t value  Pr(>|t|) #> (Intercept)   0.1289     0.0992   1.299 1.938e-01 #> x             0.7062     0.1213   5.822 5.819e-09 library(nlme) #>  #> Attaching package: 'nlme' #> The following object is masked from 'package:lme4': #>  #>     lmList mod_nlme <- lme(y ~ x,   data = hsced, random = list(id = ~1),   weights = varIdent(form = ~ 1 | item), method = \"ML\" ) summary(mod_nlme) #> Linear mixed-effects model fit by maximum likelihood #>   Data: hsced  #>       AIC      BIC   logLik #>   4126.28 4151.731 -2058.14 #>  #> Random effects: #>  Formula: ~1 | id #>         (Intercept)  Residual #> StdDev:   0.9940033 0.9796423 #>  #> Variance function: #>  Structure: Different standard deviations per stratum #>  Formula: ~1 | item  #>  Parameter estimates: #>        1        2  #> 1.000000 1.412369  #> Fixed effects:  y ~ x  #>                 Value  Std.Error  DF  t-value p-value #> (Intercept) 0.1288960 0.09927455 999 1.298379  0.1945 #> x           0.7062301 0.12130578 999 5.821899  0.0000 #>  Correlation:  #>   (Intr) #> x -0.624 #>  #> Standardized Within-Group Residuals: #>         Min          Q1         Med          Q3         Max  #> -4.00355402 -0.60661607  0.02357892  0.60903083  3.06299731  #>  #> Number of Observations: 1200 #> Number of Groups: 200 plot(mod) mod0 <- galamm(   formula = y ~ x + (1 | id),   data = hsced ) anova(mod, mod0) #> Data: hsced #> Models: #> mod0: y ~ x + (1 | id) #> mod: y ~ x + (1 | id) #>      npar    AIC    BIC  logLik deviance  Chisq Df Pr(>Chisq)     #> mod0    4 4171.6 4191.9 -2081.8   4116.3                          #> mod     5 4126.3 4151.7 -2058.1   4116.3 47.281  1   6.15e-12 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/articles/mixed_response.html","id":"mixed-normal-and-binomial-response","dir":"Articles","previous_headings":"","what":"Mixed Normal and Binomial Response","title":"Models with Mixed Response Types","text":"start mresp dataset, comes package. variable “itemgroup” defines response type; equals “” normally distributed responses “b” binomially distributed responses. link common random intercept. terms GALAMM defined introductory vignette, simplicity assuming use canonical link functions, response model \\[ f\\left(y_{ij} | \\nu_{ij}, \\phi\\right) = \\exp \\left( \\frac{y_{ij}\\nu_{ij} - b\\left(\\nu_{ij}\\right)}{\\phi} + c\\left(y_{ij}, \\phi\\right) \\right) \\] \\(\\)th observation \\(j\\) subject. Although don’t show subscript, variable itemgroup = \"\" Gaussian response, \\(b(\\nu) = \\nu^{2}/2\\) support distribution entire real line \\(\\mathbb{R}\\). mean case given \\(\\mu_{ij} = \\nu_{ij}\\). itemgroup = \"b\" binomial response, \\(b(\\nu) = \\log(1 + \\exp(\\nu))\\) support \\(\\{0, 1\\}\\). binomial case also \\(\\phi=1\\). mean case given \\(\\mu_{ij} = \\exp(\\nu_{ij}) / (1 + \\exp(\\nu_{ij}))\\). function \\(c(y_{ij}, \\phi)\\) also differs cases, interest, since depend linear predictor. hence matters value log-likelihood, derivative respect parameters interest. Next, nonlinear predictor given \\[\\nu_{ij} = \\beta_{0} + x_{ij}\\beta_{1} + \\mathbf{z}_{ij}^{T}\\boldsymbol{\\lambda} \\eta\\] \\(x_{ij}\\) explanatory \\(\\mathbf{z}_{ij}\\) dummy vector length 2 exactly one element equal one one element equal zero. itemgroup = \"\", \\(\\mathbf{z} = (1, 0)^{T}\\) itemgroup = \"b\", \\(\\mathbf{z} = (0, 1)^{T}\\). parameter \\(\\boldsymbol{\\lambda} = (1, \\lambda)^{T}\\) vector factor loadings, whose first element equals zero identifiability. \\(\\eta\\) latent variable, case representing underlying trait “causing” observed responses. structural model simply \\[ \\eta = \\zeta \\sim N(0, \\psi), \\] \\(N(0, \\psi)\\) denotes normal distribution mean 0 variance \\(\\psi\\). define loading matrix follows, value 1 indicates first element \\(\\boldsymbol{\\lambda}\\) fixed, value NA indicates second element unknown, estimated. set load.var = \"itemgroup\" rows data value itemgroup receive factor loading. formula, state (0 + level | id) specify subject, identified id, given level. level element mresp data, instead factor onto loading matrix loads. identify argument factor = list(\"level\"). chosen name \"level\", except names already columns mresp. also need define response families, vector also need way telling galamm row belongs family, family mapping. values family_mapping refer elements families. now ready estimate mixed response model. can also look summary output.","code":"head(mresp) #>   id         x          y itemgroup #> 1  1 0.8638214  0.2866329         a #> 2  1 0.7676133  2.5647490         a #> 3  1 0.8812059  1.0000000         b #> 4  1 0.2239725  1.0000000         b #> 5  2 0.7215696 -0.4721698         a #> 6  2 0.6924851  1.1750286         a (loading_matrix <- matrix(c(1, NA), ncol = 1)) #>      [,1] #> [1,]    1 #> [2,]   NA families <- c(gaussian, binomial) family_mapping <- ifelse(mresp$itemgroup == \"a\", 1, 2) mixed_resp <- galamm(   formula = y ~ x + (0 + level | id),   data = mresp,   family = families,   family_mapping = family_mapping,   load.var = \"itemgroup\",   lambda = list(loading_matrix),   factor = list(\"level\") ) summary(mixed_resp) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ x + (0 + level | id) #>    Data: mresp #>  #>      AIC      BIC   logLik deviance df.resid  #>   9248.7   9280.2  -4619.3   3633.1     3995  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -3.5360 -0.7078  0.2156  0.6456  2.5978  #>  #> Lambda: #>         level      SE #> lambda1 1.000       . #> lambda2 1.095 0.09982 #>  #> Random effects: #>  Groups Name  Variance Std.Dev. #>  id     level 1.05     1.025    #> Number of obs: 4000, groups:  id, 1000 #>  #> Fixed effects: #>             Estimate Std. Error z value  Pr(>|z|) #> (Intercept)    0.041    0.05803  0.7065 4.799e-01 #> x              0.971    0.08594 11.2994 1.321e-29"},{"path":"https://lcbc-uio.github.io/galamm/articles/mixed_response.html","id":"mixed-response-and-heteroscedastic-residuals","dir":"Articles","previous_headings":"Mixed Normal and Binomial Response","what":"Mixed Response and Heteroscedastic Residuals","title":"Models with Mixed Response Types","text":"Mixed response models can combined heteroscedastic residuals, described vignette linear mixed models heteroscedastic residuals. However, care needed case. illustrate dataset mresp_hsced, whose first lines shown : dataset structure mresp, except residual standard deviation normally distributed responses vary according variable grp, two levels. Two fit model dataset heteroscedastic residuals normally distributed variable, must use dummy variable isgauss setting weights. illustrated . writing ~ (0 + isgauss | grp) specify heteroscedasticity assumed levels grp, applies isgauss nonzero. Hence, binomially distributed responses don’t heteroscedastic residuals estimated, since observations dispersion parameter \\(\\phi\\) fixed 1. also ignore factor loadings simplicity. summary output now shows also estimated variance function.","code":"head(mresp_hsced) #>   id         x           y itemgroup grp isgauss #> 1  1 0.8638214   0.2866329         a   b       1 #> 2  1 0.7676133   2.5647490         a   b       1 #> 3  1 0.8812059   1.0000000         b   b       0 #> 4  1 0.2239725   1.0000000         b   b       0 #> 5  2 0.7215696 -11.0020148         a   a       1 #> 6  2 0.6924851   1.1750286         a   b       1 family_mapping <- ifelse(mresp$itemgroup == \"a\", 1L, 2L) mod <- galamm(   formula = y ~ x + (1 | id),   weights = ~ (0 + isgauss | grp),   family = c(gaussian, binomial),   family_mapping = family_mapping,   data = mresp_hsced ) summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ x + (1 | id) #>    Data: mresp_hsced #> Weights: ~(0 + isgauss | grp) #>  #>      AIC      BIC   logLik deviance df.resid  #>  12356.9  12388.3  -6173.4  31426.4     3995  #>  #> Scaled residuals:  #>      Min       1Q   Median       3Q      Max  #> -15.2275  -0.4025   0.1262   0.6757  16.0284  #>  #> Random effects: #>  Groups Name        Variance Std.Dev. #>  id     (Intercept) 0        0        #> Number of obs: 4000, groups:  id, 1000 #>  #> Variance function: #>       a       b  #> 1.00000 0.07756  #>  #> Fixed effects: #>             Estimate Std. Error z value  Pr(>|z|) #> (Intercept)  0.01523    0.06303  0.2416 8.091e-01 #> x            0.99563    0.11153  8.9267 4.388e-19"},{"path":"https://lcbc-uio.github.io/galamm/articles/mixed_response.html","id":"covariate-measurement-error-model","dir":"Articles","previous_headings":"","what":"Covariate Measurement Error Model","title":"Models with Mixed Response Types","text":"example taken Chapter 14.2 Skrondal Rabe-Hesketh (2004), follows analyses (Rabe-Hesketh, Pickles, Skrondal 2003; Rabe-Hesketh, Skrondal, Pickles 2003). originality claimed respect analyses; sake understanding galamm code, explain quite detail. original dataset comes Morris, Marr, Clayton (1977). scientific question concerns impact fiber intake risk coronary heat disease. 337 middle aged men followed, either worked bank staff London Transport staff (indicated dummy variable bus). men first measurement fiber intake, additional measurement six months later. addition, binary variable indicating whether developed coronary heart disease. first rows dataset printed . single measurement fiber intake. instructive also look men two measurements fiber intake. three .","code":"head(diet) #>   id   age bus   item         y chd fiber fiber2 #> 1  1 -0.38   1 fiber1 17.814280   0     1      0 #> 2  1 -0.38   1    chd  0.000000   1     0      0 #> 3  2  0.54   1 fiber1  9.487736   0     1      0 #> 4  2  0.54   1    chd  0.000000   1     0      0 #> 5  3  8.78   1 fiber1 15.958630   0     1      0 #> 6  3  8.78   1    chd  0.000000   1     0      0 diet[diet$id %in% c(219, 220, 221), ] #>      id   age bus   item        y chd fiber fiber2 #> 429 219 -8.13   0 fiber1 15.64263   0     1      0 #> 430 219 -8.13   0 fiber2 14.87973   0     1      1 #> 431 219 -8.13   0    chd  0.00000   1     0      0 #> 432 220 -1.13   0 fiber1 13.46374   0     1      0 #> 433 220 -1.13   0 fiber2 14.73168   0     1      1 #> 434 220 -1.13   0    chd  0.00000   1     0      0 #> 435 221  3.67   0 fiber1 15.95863   0     1      0 #> 436 221  3.67   0 fiber2 17.28778   0     1      1 #> 437 221  3.67   0    chd  0.00000   1     0      0"},{"path":"https://lcbc-uio.github.io/galamm/articles/mixed_response.html","id":"structural-model","dir":"Articles","previous_headings":"Covariate Measurement Error Model","what":"Structural Model","title":"Models with Mixed Response Types","text":"first goal model effect fiber intake risk heart disease. Since variable likely subject measurement error, well known simply averaging two measurements, available, using single measurement otherwise, lead bias lack power (Carroll et al. 2006). Instead, let \\(\\eta_{j}\\) denote true (latent) fiber intake person \\(j\\), define structural model \\[\\eta_{j} = \\mathbf{x}_{ij}'\\boldsymbol{\\gamma} + \\zeta_{j}.\\] \\(\\mathbf{x}_{ij}\\) vector covariates age, bus, interaction, well constant term defining intercept. R formula setting model matrix model.matrix(~ age * bus, data = diet). term \\(\\zeta_{j}\\) normally distributed disturbance, \\(\\zeta_{j} \\sim N(0, \\psi)\\).","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/mixed_response.html","id":"measurement-model","dir":"Articles","previous_headings":"Covariate Measurement Error Model","what":"Measurement Model","title":"Models with Mixed Response Types","text":"assumed fiber measurements normally distributed around true value \\(\\eta_{j}\\), allow drift term \\(d_{ij}\\beta_{0}\\), \\(d_{2ij}\\) dummy variable whose value equals one \\(\\)th row \\(j\\)th person replicate fiber measurement, zero otherwise. allows drift measurements, model becomes \\[y_{ij} = d_{2ij} \\beta_{0} + \\eta_{j} + \\epsilon_{ij}, \\qquad \\epsilon_{ij} = N(0, \\theta).\\]","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/mixed_response.html","id":"disease-model","dir":"Articles","previous_headings":"Covariate Measurement Error Model","what":"Disease Model","title":"Models with Mixed Response Types","text":"Next, rows corresponding coronary heart disease measurement, assume binomial model logit link function, .e., logistic regression. model given \\[\\text{logit}[P(y_{ij}=1 | \\eta_{j})] = \\mathbf{x}_{ij}'\\boldsymbol{\\beta} + \\lambda \\eta_{j},\\] \\(\\mathbf{x}_{ij}\\) , \\(\\boldsymbol{\\beta}\\) now represents direct effect age bus probability coronary heart disease. factor loading \\(\\lambda\\) regression coefficient latent fiber intake risk coronary heart disease.","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/mixed_response.html","id":"nonlinear-predictor","dir":"Articles","previous_headings":"Covariate Measurement Error Model","what":"Nonlinear Predictor","title":"Models with Mixed Response Types","text":"Stacking three responses, fiber intake times 1 2, coronary heart disease, can define joint model GLLAMM nonlinear predictor \\[\\nu_{ij} = d_{2ij} \\beta_{0} + d_{3ij} \\mathbf{x}_{j}'\\boldsymbol{\\beta} + \\mathbf{x}_{j}'\\boldsymbol{\\gamma}\\left[(d_{1i} + d_{2i}) + \\lambda d_{3i}\\right] + \\zeta_{j} \\left[(d_{1i} + d_{2i}) + \\lambda d_{3i}\\right],\\] \\(d_{1i}\\) dummy variable fiber measurements timepoint 1 \\(d_{3i}\\) indicator coronary heart disease.","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/mixed_response.html","id":"estimating-the-model-with-galamm","dir":"Articles","previous_headings":"Covariate Measurement Error Model","what":"Estimating the Model with galamm","title":"Models with Mixed Response Types","text":"measurement model fiber , note implicitly factor loadings equal one. Letting item variable define rows receive loading, note factor levels follows: course changed , given levels, define following loading matrix: , “fiber1” “fiber2” receive loading fixed one, whereas loading “chd” remains estimated. also need define families, making sure binomial “chd” Gaussian “fiber1” “fiber2”. model formula also needs care case. define follows, note whole part 0 + chd + fiber + fiber2 replaced item. use former ease explanation. initial zero specifies don’t want R insert intercept term. Next, chd + (age * bus) : chd applies “chd” rows , corresponds \\(\\mathbf{x}_{ij}^{T} \\boldsymbol{\\beta}\\) disease model. part fiber + (age * bus) : fiber corresponds term \\(\\mathbf{x}_{ij}^{T}\\boldsymbol{\\gamma}\\) disease model, fiber2 corresponds drift term \\(d_{2ij}\\beta_{0}\\). can inspect model implied formula using nobars function lme4 (Bates et al. 2015) remove random effects, model.matrix. looks correctly set . Finally, random effects part (0 + loading | id) specifies id single random intercept, corresponds latent fiber intake \\(\\eta_{j}\\). Writing 0 + loading means \\(\\eta_{j}\\) multiplied factor loadings defined loading matrix. now ready fit model. Looking summary output, however, see warning Hessian matrix rank deficient. suspect convergence issue algorithm, start simply turning lever make algorithm verbose. argument trace = 3 passed onto optim. Now got information, final estimate , since otherwise used parameters. now instead try increase initial estimate random effect parameter \\(\\theta\\). general \\(\\theta\\) vector containing elements Cholesky factor covariance matrix (see, Bates et al. (2015)), case just standard deviation latent variable. default, initial value 1, now try increase 10, start argument. output printed negative log-likelihood, since 1372.16 less 1406.8, increasing initial value 10 led us local optimum higher likelihood value. Ideally tried initial values well, since Skrondal Rabe-Hesketh (2004) obtained negative log-likelihood value 1372.35 using adaptive quadrature estimation, pretty happy finding value close . can now use summary method, find estimates close corresponding model Table 14.1 Skrondal Rabe-Hesketh (2004). Now able reproduce results close Table 14.1 page 420 Skrondal Rabe-Hesketh (2004). useful assurance algorithm used galamm correctly implemented.","code":"levels(diet$item) #> [1] \"fiber1\" \"fiber2\" \"chd\" (loading_matrix <- matrix(c(1, 1, NA), ncol = 1)) #>      [,1] #> [1,]    1 #> [2,]    1 #> [3,]   NA families <- c(gaussian, binomial) family_mapping <- ifelse(diet$item == \"chd\", 2, 1) formula <- y ~ 0 + chd + (age * bus):chd + fiber +   (age * bus):fiber + fiber2 + (0 + loading | id) head(model.matrix(nobars(formula), data = diet)) #>   chd fiber fiber2 chd:age chd:bus age:fiber bus:fiber chd:age:bus age:bus:fiber #> 1   0     1      0    0.00       0     -0.38         1        0.00         -0.38 #> 2   1     0      0   -0.38       1      0.00         0       -0.38          0.00 #> 3   0     1      0    0.00       0      0.54         1        0.00          0.54 #> 4   1     0      0    0.54       1      0.00         0        0.54          0.00 #> 5   0     1      0    0.00       0      8.78         1        0.00          8.78 #> 6   1     0      0    8.78       1      0.00         0        8.78          0.00 mod <- galamm(   formula = formula,   data = diet,   family = families,   family_mapping = family_mapping,   factor = list(\"loading\"),   load.var = \"item\",   lambda = list(loading_matrix) ) summary(mod) #> Warning in vcov.galamm(object, parm = \"lambda\"): Rank deficient Hessian matrix.Could not compute covariance matrix. #> Warning in vcov.galamm(object, \"beta\"): Rank deficient Hessian matrix.Could not compute covariance matrix. #> GALAMM fit by maximum marginal likelihood. #> Formula: formula #>    Data: diet #>  #>      AIC      BIC   logLik deviance df.resid  #>   2837.6   2892.9  -1406.8  12529.3      730  #>  #> Scaled residuals:  #>      Min       1Q   Median       3Q      Max  #> -10.1375  -0.4389  -0.3522   0.2743  27.3350  #>  #> Lambda: #>         loading SE #> lambda1   1.000  . #> lambda2   1.000  . #> lambda3  -2.026  . #>  #> Random effects: #>  Groups Name    Variance Std.Dev. #>  id     loading 0        0        #> Number of obs: 742, groups:  id, 333 #>  #> Fixed effects: #>               Estimate Std. Error z value Pr(>|z|) #> chd           -1.78692         NA      NA       NA #> fiber         17.96184         NA      NA       NA #> fiber2        -0.64927         NA      NA       NA #> chd:age        0.06682         NA      NA       NA #> chd:bus       -0.06882         NA      NA       NA #> fiber:age     -0.20480         NA      NA       NA #> fiber:bus     -1.69601         NA      NA       NA #> chd:age:bus   -0.04934         NA      NA       NA #> fiber:age:bus  0.16097         NA      NA       NA mod <- galamm(   formula = formula,   data = diet,   family = families,   family_mapping = family_mapping,   factor = list(\"loading\"),   load.var = \"item\",   lambda = list(loading_matrix),   control = galamm_control(optim_control = list(trace = 3)) ) #> N = 11, M = 20 machine precision = 2.22045e-16 #> At X0, 0 variables are exactly at the bounds #> At iterate     0  f=         2148  |proj g|=       122.68 #> At iterate    10  f =       1770.3  |proj g|=        30.656 #> At iterate    20  f =       1467.2  |proj g|=        11.286 #> At iterate    30  f =       1417.6  |proj g|=        73.904 #> At iterate    40  f =       1406.8  |proj g|=       0.21144 #>  #> iterations 43 #> function evaluations 51 #> segments explored during Cauchy searches 44 #> BFGS updates skipped 0 #> active bounds at final generalized Cauchy point 1 #> norm of the final projected gradient 0.0123301 #> final function value 1406.8 #>  #> F = 1406.8 #> final  value 1406.801105  #> converged mod <- galamm(   formula = formula,   data = diet,   family = families,   family_mapping = family_mapping,   factor = list(\"loading\"),   load.var = \"item\",   lambda = list(loading_matrix),   start = list(theta = 10),   control = galamm_control(optim_control = list(trace = 3)) ) #> N = 11, M = 20 machine precision = 2.22045e-16 #> At X0, 0 variables are exactly at the bounds #> At iterate     0  f=       2827.6  |proj g|=       123.31 #> At iterate    10  f =       1764.5  |proj g|=        103.86 #> At iterate    20  f =       1623.6  |proj g|=        131.81 #> At iterate    30  f =       1442.4  |proj g|=        35.169 #> At iterate    40  f =         1388  |proj g|=        20.654 #> At iterate    50  f =       1372.4  |proj g|=        1.4042 #>  #> iterations 57 #> function evaluations 69 #> segments explored during Cauchy searches 58 #> BFGS updates skipped 0 #> active bounds at final generalized Cauchy point 0 #> norm of the final projected gradient 0.0119052 #> final function value 1372.16 #>  #> F = 1372.16 #> final  value 1372.160387  #> converged summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: formula #>    Data: diet #> Control: galamm_control(optim_control = list(trace = 3)) #>  #>      AIC      BIC   logLik deviance df.resid  #>   2768.3   2823.6  -1372.2   2002.9      730  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -258547      -1       0       0      66  #>  #> Lambda: #>         loading      SE #> lambda1  1.0000       . #> lambda2  1.0000       . #> lambda3 -0.1339 0.05121 #>  #> Random effects: #>  Groups Name    Variance Std.Dev. #>  id     loading 23.64    4.862    #> Number of obs: 742, groups:  id, 333 #>  #> Fixed effects: #>               Estimate Std. Error  z value   Pr(>|z|) #> chd           -1.91520    0.27229 -7.03361  2.013e-12 #> fiber         17.94834    0.48686 36.86566 1.641e-297 #> fiber2         0.22406    0.41783  0.53624  5.918e-01 #> chd:age        0.06613    0.05931  1.11515  2.648e-01 #> chd:bus       -0.02900    0.34355 -0.08441  9.327e-01 #> fiber:age     -0.21207    0.10090 -2.10172  3.558e-02 #> fiber:bus     -1.68278    0.63721 -2.64084  8.270e-03 #> chd:age:bus   -0.04998    0.06507 -0.76812  4.424e-01 #> fiber:age:bus  0.16821    0.11223  1.49882  1.339e-01"},{"path":"https://lcbc-uio.github.io/galamm/articles/mixed_response.html","id":"comparison-to-a-model-with-indirect-effect-only","dir":"Articles","previous_headings":"Covariate Measurement Error Model","what":"Comparison to a Model with Indirect Effect Only","title":"Models with Mixed Response Types","text":"model assumed age bus variables indirect effect risk coronary heart disease impact fiber intake, well direct effect. Still following Skrondal Rabe-Hesketh (2004), now estimate alternative model indirect effects. disease model now \\[ \\text{logit}[P(y_{ij}=1 | \\eta_{j})] = d_{ij3}\\beta_{03} + \\lambda \\eta_{j}, \\] formula becomes Everything else , fit new model Looking summary output, estimates now close first column Table 14.1 Skrondal Rabe-Hesketh (2004). can use anova method galamm objects compare models. AIC BIC favor simpler model indirect effects.","code":"formula0 <- y ~ 0 + chd + fiber + (age * bus):fiber + fiber2 +   (0 + loading | id) mod0 <- galamm(   formula = formula0,   data = diet,   family = families,   family_mapping = family_mapping,   factor = list(\"loading\"),   load.var = \"item\",   lambda = list(loading_matrix),   start = list(theta = 10),   control = galamm_control(optim_control = list(trace = 3)) ) #> N = 8, M = 20 machine precision = 2.22045e-16 #> At X0, 0 variables are exactly at the bounds #> At iterate     0  f=       2827.6  |proj g|=       123.31 #> At iterate    10  f =       1664.7  |proj g|=        25.235 #> At iterate    20  f =       1427.9  |proj g|=        37.186 #> At iterate    30  f =       1373.5  |proj g|=        5.1449 #>  #> iterations 37 #> function evaluations 40 #> segments explored during Cauchy searches 38 #> BFGS updates skipped 0 #> active bounds at final generalized Cauchy point 0 #> norm of the final projected gradient 0.000304544 #> final function value 1373.01 #>  #> F = 1373.01 #> final  value 1373.013263  #> converged summary(mod0) #> GALAMM fit by maximum marginal likelihood. #> Formula: formula0 #>    Data: diet #> Control: galamm_control(optim_control = list(trace = 3)) #>  #>      AIC      BIC   logLik deviance df.resid  #>   2764.0   2805.5  -1373.0   2007.9      733  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -280306      -1       0       0      66  #>  #> Lambda: #>         loading      SE #> lambda1   1.000       . #> lambda2   1.000       . #> lambda3  -0.136 0.05148 #>  #> Random effects: #>  Groups Name    Variance Std.Dev. #>  id     loading 23.64    4.862    #> Number of obs: 742, groups:  id, 333 #>  #> Fixed effects: #>               Estimate Std. Error  z value   Pr(>|z|) #> chd            -1.9668    0.18248 -10.7783  4.360e-27 #> fiber          17.9741    0.48123  37.3504 2.502e-305 #> fiber2          0.2238    0.41779   0.5358  5.921e-01 #> fiber:age      -0.1896    0.09914  -1.9122  5.585e-02 #> fiber:bus      -1.6991    0.62529  -2.7173  6.581e-03 #> fiber:age:bus   0.1515    0.11012   1.3760  1.688e-01 anova(mod, mod0) #> Data: diet #> Models: #> mod0: formula0 #> mod: formula #>      npar    AIC    BIC  logLik deviance  Chisq Df Pr(>Chisq) #> mod0    9 2764.0 2805.5 -1373.0   2002.9                      #> mod    12 2768.3 2823.6 -1372.2   2002.9 1.7058  3     0.6357"},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/articles/optimization.html","id":"high-level-overview","dir":"Articles","previous_headings":"","what":"High-Level Overview","title":"Optimization","text":"optimization procedure used galamm described Section 3 Sørensen, Fjell, Walhovd (2023). consists two steps: inner loop, marginal likelihood evaluated given set parameters. marginal likelihood obtain integrating random effects, integration done Laplace approximation. Laplace approximation yields large system equations needs solved iteratively, except case conditionally Gaussian responses unit link function, single step sufficient solve system. written matrix-vector form, system equations cases overwhelming majority zeros, avoid wasting memory time storing multiplying zero, use sparse matrix methods. outer loop, try find parameters maximize marginal likelihood. new set parameters, whole procedure inner loop repeated. default, use limited memory Broyden-Fletcher-Goldfard-Shanno algorithm box constraints (Byrd et al. 1995), abbreviated L-BFGS-B. particular, use implementation R’s optim() function, obtained setting method = \"L-BFGS-B\". L-BFGS-B requires first derivatives, obtained automatic differentiation (Skaug 2002). use cases galamm, also use constraints parameters, e.g., ensure variances non-negative. alternative, Nelder-Mead algorithm box constraints (Bates et al. 2015; Nelder Mead 1965) lme4 also available. Since Nelder-Mead algorithm derivative free, automatic differentiation used case, except computing Hessian matrix final step. convergence, Hessian matrix second derivatives computed exactly, using automatic differentiation. inverse matrix covariance matrix parameter estimates, used compute Wald type confidence intervals.","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/optimization.html","id":"modifying-the-l-bfgs-b-algorithm","dir":"Articles","previous_headings":"","what":"Modifying the L-BFGS-B algorithm","title":"Optimization","text":"illustrate ways modifying optimization procedure covariate measurement model example shown vignette models mixed response types. start simply setting need fit model. Fitting model default arguments yields warning look summary object. case, can increase amount information provided optim, trace argument. avoid getting much output, also reduce number iterations. set control argument follows: , maxit = 5 means take 5 iterations, trace = 3 means want information L-BFGS-B, REPORT= = 1 means want L-BFGS-B report information step takes. provide object control argument galamm, rerun model: Since simply turn reporting, surprise Hessian still rank deficient, output, also clear obvious errors, like values diverge infinity. latter may also happen time time. default, L-BFGS-B uses last 5 evaluations gradient approximate Hessian used optimization (confused exact Hessian compute automatic differentiation convergence). try increase 25, see makes difference. done lmm argument. also reduce amount reporting every 10th step, avoid setting maximum number iterations, means optim()’s default option used. clear neither solved issue. Looking model output , see random effect variance estimated exactly zero. types obviously wrong zero variance estimates well-known users mixed models (Hodges 2013). see increasing initial value variance parameter solves issue. done start argument galamm. start argument requires named list, optional arguments theta, beta, lambda, weights, giving initial values groups parameters. case theta standard deviation random effect, increase 10 see happens. default, initial value equals 1. Now see model converged Hessian longer rank deficient.","code":"loading_matrix <- matrix(c(1, 1, NA), ncol = 1) families <- c(gaussian, binomial) family_mapping <- ifelse(diet$item == \"chd\", 2, 1) formula <- y ~ 0 + chd + (age * bus):chd + fiber +   (age * bus):fiber + fiber2 + (0 + loading | id) mod <- galamm(   formula = formula,   data = diet,   family = families,   family_mapping = family_mapping,   factor = list(\"loading\"),   load.var = \"item\",   lambda = list(loading_matrix) )  summary(mod) #> Warning in vcov.galamm(object, parm = \"lambda\"): Rank deficient Hessian matrix.Could not compute covariance matrix. #> Warning in vcov.galamm(object, \"beta\"): Rank deficient Hessian matrix.Could not compute covariance matrix. #> GALAMM fit by maximum marginal likelihood. #> Formula: formula #>    Data: diet #>  #>      AIC      BIC   logLik deviance df.resid  #>   2837.6   2892.9  -1406.8  12529.3      730  #>  #> Scaled residuals:  #>      Min       1Q   Median       3Q      Max  #> -10.1375  -0.4389  -0.3522   0.2743  27.3350  #>  #> Lambda: #>         loading SE #> lambda1   1.000  . #> lambda2   1.000  . #> lambda3  -2.026  . #>  #> Random effects: #>  Groups Name    Variance Std.Dev. #>  id     loading 0        0        #> Number of obs: 742, groups:  id, 333 #>  #> Fixed effects: #>               Estimate Std. Error z value Pr(>|z|) #> chd           -1.78692         NA      NA       NA #> fiber         17.96184         NA      NA       NA #> fiber2        -0.64927         NA      NA       NA #> chd:age        0.06682         NA      NA       NA #> chd:bus       -0.06882         NA      NA       NA #> fiber:age     -0.20480         NA      NA       NA #> fiber:bus     -1.69601         NA      NA       NA #> chd:age:bus   -0.04934         NA      NA       NA #> fiber:age:bus  0.16097         NA      NA       NA control <- galamm_control(optim_control = list(maxit = 5, trace = 3, REPORT = 1)) mod <- galamm(   formula = formula,   data = diet,   family = families,   family_mapping = family_mapping,   factor = list(\"loading\"),   load.var = \"item\",   lambda = list(loading_matrix),   control = control ) #> N = 11, M = 20 machine precision = 2.22045e-16 #> At X0, 0 variables are exactly at the bounds #> At iterate     0  f=         2148  |proj g|=       122.68 #> At iterate     1  f =       2132.1  |proj g|=        275.51 #> At iterate     2  f =       2100.1  |proj g|=         193.7 #> At iterate     3  f =       1975.6  |proj g|=        177.11 #> At iterate     4  f =       1923.2  |proj g|=         165.7 #> At iterate     5  f =       1898.8  |proj g|=        83.839 #> At iterate     6  f =       1887.9  |proj g|=        49.147 #> final  value 1887.871646  #> stopped after 6 iterations vcov(mod) #> Warning in vcov.galamm(mod): Rank deficient Hessian matrix.Could not compute covariance matrix. #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [2,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [3,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [4,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [5,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [6,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [7,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [8,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [9,]   NA   NA   NA   NA   NA   NA   NA   NA   NA control <- galamm_control(optim_control = list(trace = 3, REPORT = 10, lmm = 25)) mod <- galamm(   formula = formula,   data = diet,   family = families,   family_mapping = family_mapping,   factor = list(\"loading\"),   load.var = \"item\",   lambda = list(loading_matrix),   control = control ) #> N = 11, M = 25 machine precision = 2.22045e-16 #> At X0, 0 variables are exactly at the bounds #> At iterate     0  f=         2148  |proj g|=       122.68 #> At iterate    10  f =       1770.3  |proj g|=        30.656 #> At iterate    20  f =       1467.2  |proj g|=        11.286 #> At iterate    30  f =         1413  |proj g|=        4.3102 #>  #> iterations 38 #> function evaluations 44 #> segments explored during Cauchy searches 39 #> BFGS updates skipped 0 #> active bounds at final generalized Cauchy point 1 #> norm of the final projected gradient 0.001689 #> final function value 1406.8 #>  #> F = 1406.8 #> final  value 1406.801104  #> converged vcov(mod) #> Warning in vcov.galamm(mod): Rank deficient Hessian matrix.Could not compute covariance matrix. #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [2,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [3,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [4,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [5,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [6,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [7,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [8,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [9,]   NA   NA   NA   NA   NA   NA   NA   NA   NA summary(mod) #> Warning in vcov.galamm(object, parm = \"lambda\"): Rank deficient Hessian matrix.Could not compute covariance matrix. #> Warning in vcov.galamm(object, \"beta\"): Rank deficient Hessian matrix.Could not compute covariance matrix. #> GALAMM fit by maximum marginal likelihood. #> Formula: formula #>    Data: diet #> Control: control #>  #>      AIC      BIC   logLik deviance df.resid  #>   2837.6   2892.9  -1406.8  12529.3      730  #>  #> Scaled residuals:  #>      Min       1Q   Median       3Q      Max  #> -10.1374  -0.4390  -0.3523   0.2743  27.3347  #>  #> Lambda: #>         loading SE #> lambda1   1.000  . #> lambda2   1.000  . #> lambda3  -1.922  . #>  #> Random effects: #>  Groups Name    Variance Std.Dev. #>  id     loading 0        0        #> Number of obs: 742, groups:  id, 333 #>  #> Fixed effects: #>               Estimate Std. Error z value Pr(>|z|) #> chd           -1.78673         NA      NA       NA #> fiber         17.96179         NA      NA       NA #> fiber2        -0.64904         NA      NA       NA #> chd:age        0.06685         NA      NA       NA #> chd:bus       -0.06894         NA      NA       NA #> fiber:age     -0.20479         NA      NA       NA #> fiber:bus     -1.69628         NA      NA       NA #> chd:age:bus   -0.04937         NA      NA       NA #> fiber:age:bus  0.16092         NA      NA       NA mod <- galamm(   formula = formula,   data = diet,   family = families,   family_mapping = family_mapping,   factor = list(\"loading\"),   load.var = \"item\",   lambda = list(loading_matrix),   start = list(theta = 10),   control = control ) #> N = 11, M = 25 machine precision = 2.22045e-16 #> At X0, 0 variables are exactly at the bounds #> At iterate     0  f=       2827.6  |proj g|=       123.31 #> At iterate    10  f =       1764.5  |proj g|=        103.86 #> At iterate    20  f =       1623.6  |proj g|=        131.81 #> At iterate    30  f =       1447.9  |proj g|=        75.096 #> At iterate    40  f =       1400.5  |proj g|=        35.591 #> At iterate    50  f =       1373.1  |proj g|=        3.3359 #> At iterate    60  f =       1372.2  |proj g|=     0.0016541 #>  #> iterations 60 #> function evaluations 72 #> segments explored during Cauchy searches 61 #> BFGS updates skipped 0 #> active bounds at final generalized Cauchy point 0 #> norm of the final projected gradient 0.00165415 #> final function value 1372.16 #>  #> F = 1372.16 #> final  value 1372.160386  #> converged summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: formula #>    Data: diet #> Control: control #>  #>      AIC      BIC   logLik deviance df.resid  #>   2768.3   2823.6  -1372.2   2002.9      730  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -258522      -1       0       0      66  #>  #> Lambda: #>         loading      SE #> lambda1  1.0000       . #> lambda2  1.0000       . #> lambda3 -0.1339 0.05121 #>  #> Random effects: #>  Groups Name    Variance Std.Dev. #>  id     loading 23.64    4.862    #> Number of obs: 742, groups:  id, 333 #>  #> Fixed effects: #>               Estimate Std. Error  z value   Pr(>|z|) #> chd           -1.91525    0.27229 -7.03373  2.011e-12 #> fiber         17.94849    0.48686 36.86601 1.620e-297 #> fiber2         0.22402    0.41783  0.53614  5.919e-01 #> chd:age        0.06615    0.05931  1.11531  2.647e-01 #> chd:bus       -0.02895    0.34355 -0.08427  9.328e-01 #> fiber:age     -0.21204    0.10090 -2.10135  3.561e-02 #> fiber:bus     -1.68303    0.63721 -2.64123  8.261e-03 #> chd:age:bus   -0.04999    0.06507 -0.76822  4.424e-01 #> fiber:age:bus  0.16818    0.11223  1.49854  1.340e-01"},{"path":"https://lcbc-uio.github.io/galamm/articles/optimization.html","id":"optimization-with-the-nelder-mead-algorithm","dir":"Articles","previous_headings":"","what":"Optimization with the Nelder-Mead algorithm","title":"Optimization","text":"Nelder-Mead algorithm turned setting method = \"Nelder-Mead\" calling galamm_control(). also turn reporting every 20th function evaluation setting verbose = 1: provide estimates obtained L-BFGS-B algorithm initial values. can use convenience function extract_optim_parameters: now fit model, providing initial values start argument. summary output shows Nelder-Mead found exactly optimum particular case, surprising given intial values provided.","code":"control <- galamm_control(   optim_control = list(verbose = 1),   method = \"Nelder-Mead\"   ) start <- extract_optim_parameters(mod) mod_nm <- galamm(   formula = formula,   data = diet,   family = families,   family_mapping = family_mapping,   factor = list(\"loading\"),   load.var = \"item\",   lambda = list(loading_matrix),   control = control,   start = start ) #> (NM) 20: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 40: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 60: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 80: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 100: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 120: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 140: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 160: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 180: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 200: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 220: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 240: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 260: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 280: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 300: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 320: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 340: f = 1372.16 at    1.84246   -1.91525    17.9485   0.224017   0.066146 -0.0289499  -0.212035   -1.68303 -0.0499864   0.168178  -0.133909 #> (NM) 360: f = 1372.16 at    1.84247   -1.91525    17.9485   0.223968  0.0661412  -0.028921   -0.21203   -1.68308 -0.0499804   0.168172  -0.133908 #> (NM) 380: f = 1372.16 at    1.84247   -1.91525    17.9485    0.22398  0.0661421 -0.0289289  -0.212034   -1.68304 -0.0499816   0.168174  -0.133909 #> (NM) 400: f = 1372.16 at    1.84247   -1.91525    17.9485   0.223986  0.0661415 -0.0289274  -0.212031   -1.68305 -0.0499811   0.168171  -0.133909 #> (NM) 420: f = 1372.16 at    1.84247   -1.91525    17.9485   0.223985  0.0661434 -0.0289358  -0.212032   -1.68304 -0.0499824   0.168172  -0.133908 summary(mod_nm) #> GALAMM fit by maximum marginal likelihood. #> Formula: formula #>    Data: diet #> Control: control #>  #>      AIC      BIC   logLik deviance df.resid  #>   2768.3   2823.6  -1372.2   2002.9      730  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -258524      -1       0       0      66  #>  #> Lambda: #>         loading      SE #> lambda1  1.0000       . #> lambda2  1.0000       . #> lambda3 -0.1339 0.05121 #>  #> Random effects: #>  Groups Name    Variance Std.Dev. #>  id     loading 23.64    4.862    #> Number of obs: 742, groups:  id, 333 #>  #> Fixed effects: #>               Estimate Std. Error  z value   Pr(>|z|) #> chd           -1.91525    0.27229 -7.03373  2.011e-12 #> fiber         17.94851    0.48686 36.86604 1.618e-297 #> fiber2         0.22398    0.41783  0.53604  5.919e-01 #> chd:age        0.06614    0.05931  1.11527  2.647e-01 #> chd:bus       -0.02893    0.34355 -0.08421  9.329e-01 #> fiber:age     -0.21203    0.10090 -2.10130  3.561e-02 #> fiber:bus     -1.68305    0.63721 -2.64126  8.260e-03 #> chd:age:bus   -0.04998    0.06507 -0.76815  4.424e-01 #> fiber:age:bus  0.16817    0.11223  1.49847  1.340e-01"},{"path":"https://lcbc-uio.github.io/galamm/articles/optimization.html","id":"implementation-details","dir":"Articles","previous_headings":"","what":"Implementation Details","title":"Optimization","text":"given set parameters, marginal likelihood evaluated completely C++. solving penalized iteratively reweighted least squares problem arising due Laplace approximation, use sparse matrix methods Eigen C++ template library RcppEigen package (Bates Eddelbuettel 2013). order keep track derivatives throughout iterative process, use autodiff library (Leal 2018). However, since autodiff natively supports dense matrix operations Eigen, extended library also supports sparse matrix operations. modified version autodiff library can found inst/include/autodiff/. order maximize marginal likelihood, currently rely optim() function R. make use fact marginal likelihood value first derivatives returned C++ function, use memoisation, provided memoise package (Wickham et al. 2021). However, optimization process still involves copying model data R C++ new set parameters. potentially efficiency bottleneck large datasets, although limited profiling done far, seems like vast majority computation time spent actually solving penalized iteratively reweighted least squares problem C++.","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/optimization.html","id":"future-improvements","dir":"Articles","previous_headings":"","what":"Future Improvements","title":"Optimization","text":"also aim perform also outer optimization loop C++, avoid copying data back forth R C++ optimization. requires finding --shelf optimization routine good L-BFGS-B implementation provided optim(), plays well autodiff.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/articles/semiparametric.html","id":"generalized-additive-mixed-models","dir":"Articles","previous_headings":"","what":"Generalized Additive Mixed Models","title":"Semiparametric Latent Variable Modeling","text":"start showing galamm can used estimated generalized additive mixed models.","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/semiparametric.html","id":"gaussian-responses","dir":"Articles","previous_headings":"Generalized Additive Mixed Models","what":"Gaussian Responses","title":"Semiparametric Latent Variable Modeling","text":"cognition dataset contains simulated data measurements abilities three cognitive domains. first example, focus first item measured first domain. subject dataset measured eight times, can plot measurements follows: Plot data domain 1 item 11. use generalized additive mixed model random intercepts per subject estimate function relating \\(x\\) \\(y\\). terms model framework outlined introductory vignette, model \\(\\)th response \\(j\\)th subject \\[ y_{ij} = f(x_{ij}) + \\eta_{j} + \\epsilon_{ij} \\] \\(f(x_{ij})\\) smooth function estimated, \\(\\eta_{j} \\sim N(0, \\psi)\\) random intercept, \\(\\epsilon_{ij} \\sim N(0, \\phi)\\) residual term. model can estimated using gamm4 follows: package gamm4 uses lme4 fit underlying model, resulting model two components. mod_gamm4$mer contains mixed model representation, whereas mod_gamm4$gam fixed random effects corresponding spline coefficients converted single smooth terms. can look model summary : can also plot estimated smooth term: Smooth term estimated gamm4. contrast, invoking plot function mixed model part gives us diagnostic plot. Diagnostic plot gamm4 model. galamm use similar argument, random specification now part model formula. opposed gamm4, galamm gives single summary. can seen, smooth terms reported random effects, separate line header “Approximate significance smooth terms:”. Reassuringly, results fitting model gamm4 galamm essentially equally, even though use somewhat different computational algorithms. plot function now gives us diagnostic plot, inspection can seen almost identical plot produced mixed model part gamm4 model. Diagnostic plot model fitted galamm. order plot smooth term, use plot_smooth. Smooth term estimated galamm. plot_smooth function thin wrapper around plot.gam function provided mgcv package (Wood 2017). means arguments used plot.gam can used also , see examples : Alternative ways visualizing smooth term. Alternative ways visualizing smooth term.","code":"head(cognition) #>   id domain          x timepoint item trials          y #> 1  1      1 0.06475113         1   11      1 0.16788973 #> 2  1      1 0.06475113         1   12      1 0.08897838 #> 3  1      1 0.06475113         1   13      1 0.03162123 #> 4  1      1 0.15766278         2   11      1 0.46598362 #> 5  1      1 0.15766278         2   12      1 0.84564656 #> 6  1      1 0.15766278         2   13      1 0.20549872 dat <- subset(cognition, domain == 1 & item == \"11\") ggplot(dat, aes(x = x, y = y, group = id)) +   geom_point(size = .1) +   geom_line(alpha = .3) mod_gamm4 <- gamm4(y ~ s(x), random = ~ (1 | id), data = dat, REML = FALSE) #> Error in gamm4(y ~ s(x), random = ~(1 | id), data = dat, REML = FALSE): unused argument (REML = FALSE) summary(mod_gamm4$mer) #> Generalized linear mixed model fit by maximum likelihood (Laplace Approximation) ['glmerMod'] #>  Family: binomial  ( logit ) #>  #>      AIC      BIC   logLik deviance df.resid  #>    983.7   1005.2   -487.8    975.7     1596  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -8.2547  0.0786  0.1946  0.4248  0.8213  #>  #> Random effects: #>  Groups Name        Variance Std.Dev. #>  id     (Intercept) 0.2306   0.4802   #>  Xr     s(x)        0.9694   0.9846   #> Number of obs: 1600, groups:  id, 200; Xr, 8 #>  #> Fixed effects: #>              Estimate Std. Error z value Pr(>|z|)     #> X(Intercept)   2.8115     0.2034  13.824  < 2e-16 *** #> Xs(x)Fx1      -1.4110     0.4242  -3.326  0.00088 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Correlation of Fixed Effects: #>          X(Int) #> Xs(x)Fx1 -0.440 summary(mod_gamm4$gam) #>  #> Family: binomial  #> Link function: logit  #>  #> Formula: #> y ~ s(x) #>  #> Parametric coefficients: #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept)   2.8115     0.1662   16.91   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Approximate significance of smooth terms: #>       edf Ref.df Chi.sq p-value     #> s(x) 2.14   2.14  113.9  <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> R-sq.(adj) =  0.116    #> glmer.ML = 908.96  Scale est. = 1         n = 1600 plot(mod_gamm4$gam) plot(mod_gamm4$mer) mod <- galamm(y ~ s(x) + (1 | id), data = dat) summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ s(x) + (1 | id) #>    Data: dat #>  #>      AIC      BIC   logLik deviance df.resid  #>   3025.2   3052.1  -1507.6   3015.2     1595  #>  #> Scaled residuals:  #>      Min       1Q   Median       3Q      Max  #> -2.93755 -0.65215  0.00612  0.62654  3.14290  #>  #> Random effects: #>  Groups   Name        Variance Std.Dev. #>  id       (Intercept) 0.8551   0.9247   #>  Xr       s(x)        2.0346   1.4264   #>  Residual             0.2501   0.5001   #> Number of obs: 1600, groups:  id, 200; Xr, 8 #>  #> Fixed effects: #>             Estimate Std. Error t value  Pr(>|t|) #> (Intercept)   1.2694    0.06657 19.0672 4.731e-81 #> s(x)Fx1      -0.1582    0.20236 -0.7818 4.343e-01 #>  #> Approximate significance of smooth terms: #>        edf Ref.df     F p-value #> s(x) 6.681  6.681 324.9  <2e-16 plot(mod) plot_smooth(mod) plot_smooth(mod,   shade = TRUE, rug = FALSE, seWithMean = TRUE,   shift = +2 ) plot_smooth(mod, se = FALSE)"},{"path":"https://lcbc-uio.github.io/galamm/articles/semiparametric.html","id":"binomial-responses","dir":"Articles","previous_headings":"Generalized Additive Mixed Models","what":"Binomial Responses","title":"Semiparametric Latent Variable Modeling","text":"cognition dataset, responses relating domain 2 binomially distributed. use first trial illustrate data can modeled. can fit model using gamm4. can look summary output . can plot smooth term. diagnostic plot useful binomial case, omit . Smooth term estimated gamm4. galamm syntax similar, puts random effect specification model formula. estimates similar, although identical. difference deviance due differences way deviance defined. call deviance(mod_gamm4$mer) gives value summary model fitted galamm. Smooth term estimated galamm.","code":"dat <- subset(cognition, domain == 2 & item == \"21\") mod_gamm4 <- gamm4(y ~ s(x),   random = ~ (1 | id),   data = dat, family = binomial ) #> Error in gamm4(y ~ s(x), random = ~(1 | id), data = dat, family = binomial): unused argument (family = binomial) summary(mod_gamm4$mer) #> Generalized linear mixed model fit by maximum likelihood (Laplace Approximation) ['glmerMod'] #>  Family: binomial  ( logit ) #>  #>      AIC      BIC   logLik deviance df.resid  #>    983.7   1005.2   -487.8    975.7     1596  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -8.2547  0.0786  0.1946  0.4248  0.8213  #>  #> Random effects: #>  Groups Name        Variance Std.Dev. #>  id     (Intercept) 0.2306   0.4802   #>  Xr     s(x)        0.9694   0.9846   #> Number of obs: 1600, groups:  id, 200; Xr, 8 #>  #> Fixed effects: #>              Estimate Std. Error z value Pr(>|z|)     #> X(Intercept)   2.8115     0.2034  13.824  < 2e-16 *** #> Xs(x)Fx1      -1.4110     0.4242  -3.326  0.00088 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Correlation of Fixed Effects: #>          X(Int) #> Xs(x)Fx1 -0.440 summary(mod_gamm4$gam) #>  #> Family: binomial  #> Link function: logit  #>  #> Formula: #> y ~ s(x) #>  #> Parametric coefficients: #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept)   2.8115     0.1662   16.91   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Approximate significance of smooth terms: #>       edf Ref.df Chi.sq p-value     #> s(x) 2.14   2.14  113.9  <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> R-sq.(adj) =  0.116    #> glmer.ML = 908.96  Scale est. = 1         n = 1600 plot(mod_gamm4$gam) mod <- galamm(y ~ s(x) + (1 | id), data = dat, family = binomial) summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ s(x) + (1 | id) #>    Data: dat #>  #>      AIC      BIC   logLik deviance df.resid  #>    983.7   1005.2   -487.8    908.8     1596  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -8.2237  0.0792  0.1947  0.4245  0.8226  #>  #> Random effects: #>  Groups Name        Variance Std.Dev. #>  id     (Intercept) 0.2316   0.4813   #>  Xr     s(x)        0.9387   0.9688   #> Number of obs: 1600, groups:  id, 200; Xr, 8 #>  #> Fixed effects: #>             Estimate Std. Error z value  Pr(>|z|) #> (Intercept)    2.808     0.1956  14.354 9.989e-47 #> s(x)Fx1       -1.406     0.4134  -3.402 6.697e-04 #>  #> Approximate significance of smooth terms: #>        edf Ref.df Chi.sq p-value #> s(x) 2.124  2.124    114  <2e-16 plot_smooth(mod)"},{"path":"https://lcbc-uio.github.io/galamm/articles/semiparametric.html","id":"generalized-additive-models-with-factor-structures","dir":"Articles","previous_headings":"","what":"Generalized Additive Models with Factor Structures","title":"Semiparametric Latent Variable Modeling","text":"now add factor structures GAMMs. types models neither gamm4 mgcv able estimate (least without lots manual hacking), galamm provides new functionality.","code":""},{"path":"https://lcbc-uio.github.io/galamm/articles/semiparametric.html","id":"gaussian-responses-1","dir":"Articles","previous_headings":"Generalized Additive Models with Factor Structures","what":"Gaussian Responses","title":"Semiparametric Latent Variable Modeling","text":"illustrate basic usage, continue cognition data, now use items cognitive domain 1. conditionally normal distributed. now need factor model associate underlying latent trait \\(\\eta\\) measurements \\(y_{}\\): \\[ y_{} = \\beta_{} + \\lambda_{} \\eta + \\epsilon_{} \\] structural model, smooth term relationship latent trait x, random intercepts given timepoint within subject \\(\\zeta^{(2)}\\), given subject across timepoints \\(\\zeta^{(3)}\\). \\[ \\eta = h(x) + \\zeta^{(2)} + \\zeta^{(3)}. \\] reduced form model \\[ y_{} = \\beta_{} + \\lambda_{} \\left\\{ h(x) + \\zeta^{(2)} + \\zeta^{(3)} \\right\\} + \\epsilon_{} \\] use varying-coefficient term, \\(h(x)\\) interpreted regression coefficient effect \\(\\lambda_{}\\) \\(y_{}\\), regression term varies \\(x\\). contrast Hastie Tibshirani (1993) uses varying-coefficient terms, however, case predictor \\(\\lambda_{}\\) model parameter. three items loading \\(\\eta\\) fix first loading 1 identifiability, loading matrix follows: provide thin wrappers around s() t2() functions mgcv support factor loadings smooth terms. wrappers named sl() t2l() avoid namespace conflicts mgcv gamm4, last letter “l” stands “loading”. example, set load.var = \"item\" specify loadings applied identified “item” variable. Using mgcv’s variable also work particular case, .e., replacing sl(x, load.var = \"loading\") s(x, = loading). However, cases lead identifiability issues due way varying-coefficient terms set mgcv, galamm provides additional load.var arguments alleviates issues. print model summary . data simulation, factor loadings set 1, 1.4, 0.3, respectively, well recovered. Furthermore, ground truth standard deviation id level 1, timepoint level 0.5, residual standard deviation 0.1. estimates close values. Real data typically strong signal, based results, clear indications model implemented incorrectly. also plot smooth term. Since large amount data, essentially uncertainty estimate. Smooth term GAMM factor structure.","code":"dat <- subset(cognition, domain == 1) head(dat) #>   id domain          x timepoint item trials          y #> 1  1      1 0.06475113         1   11      1 0.16788973 #> 2  1      1 0.06475113         1   12      1 0.08897838 #> 3  1      1 0.06475113         1   13      1 0.03162123 #> 4  1      1 0.15766278         2   11      1 0.46598362 #> 5  1      1 0.15766278         2   12      1 0.84564656 #> 6  1      1 0.15766278         2   13      1 0.20549872 (loading_matrix <- matrix(c(1, NA, NA), ncol = 1)) #>      [,1] #> [1,]    1 #> [2,]   NA #> [3,]   NA mod <- galamm(   formula = y ~ 0 + item + sl(x, load.var = \"loading\") +     (0 + loading | id / timepoint),   data = dat,   load.var = \"item\",   lambda = list(loading_matrix),   factor = list(\"loading\") ) summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ 0 + item + sl(x, load.var = \"loading\") + (0 + loading | id/timepoint) #>    Data: dat #>  #>      AIC      BIC   logLik deviance df.resid  #>   -918.2   -853.4    469.1   -938.2     4790  #>  #> Scaled residuals:  #>    Min     1Q Median     3Q    Max  #>  -2.76   6.46  13.58  23.31  35.84  #>  #> Lambda: #>         loading       SE #> lambda1  1.0000        . #> lambda2  1.3973 0.003531 #> lambda3  0.3009 0.002146 #>  #> Random effects: #>  Groups       Name         Variance Std.Dev. #>  timepoint:id loading      0.236886 0.48671  #>  id           loading      0.857051 0.92577  #>  Xr           s(x):loading 2.030613 1.42500  #>  Residual                  0.009932 0.09966  #> Number of obs: 4800, groups:  timepoint:id, 1600; id, 200; Xr, 8 #>  #> Fixed effects: #>                 Estimate Std. Error t value  Pr(>|t|) #> item11            1.2694    0.06663 19.0513 6.412e-81 #> item12            1.7788    0.09307 19.1128 1.977e-81 #> item13            0.3797    0.02019 18.8077 6.531e-79 #> s(x):loadingFx1  -0.1496    0.19977 -0.7488 4.540e-01 #>  #> Approximate significance of smooth terms: #>                edf Ref.df    F p-value #> s(x):loading 8.719  8.719 4469  <2e-16 plot_smooth(mod)"},{"path":"https://lcbc-uio.github.io/galamm/articles/semiparametric.html","id":"binomial-responses-1","dir":"Articles","previous_headings":"Generalized Additive Models with Factor Structures","what":"Binomial Responses","title":"Semiparametric Latent Variable Modeling","text":"can now move part cognition data conditionally binomially distributed. consider domain 2, response measures success single trial. case two items, must change lambda matrix accordingly. , setting family = binomial, model . summary shown . factor loading \\(\\lambda_{2} = 2\\) used simulating data, including uncertainty, estimate covers true value well. Also note variation individuals (group id) variation timepoints within individuals (group timepoint:id) gets lumped together id level. estimated variation timepoint:id level zero. well-known phenomenon fitting mixed models, given book-length treatment Hodges (2013). case, likely due fact two measurements timepoint, also fact use Laplace approximation integrate random effects, approximation may inaccurate binomial data low number repeated observations (Joe 2008). true value 2 factor loading well within 95 % confidence limits.","code":"dat <- subset(cognition, domain == 2)  mod <- galamm(   formula = y ~ 0 + item + sl(x, load.var = \"loading\") +     (0 + loading | id / timepoint),   data = dat,   family = binomial,   load.var = \"item\",   lambda = list(matrix(c(1, NA), ncol = 1)),   factor = list(\"loading\") ) summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ 0 + item + sl(x, load.var = \"loading\") + (0 + loading | id/timepoint) #>    Data: dat #>  #>      AIC      BIC   logLik deviance df.resid  #>   1495.5   1538.0   -740.8   1614.8     3193  #>  #> Scaled residuals:  #>      Min       1Q   Median       3Q      Max  #> -15.8546   0.0279   0.0780   0.1985   1.3948  #>  #> Lambda: #>         loading     SE #> lambda1   1.000      . #> lambda2   2.202 0.3007 #>  #> Random effects: #>  Groups       Name         Variance Std.Dev. #>  timepoint:id loading      0.0000   0.0000   #>  id           loading      0.6222   0.7888   #>  Xr           s(x):loading 1.5388   1.2405   #> Number of obs: 3200, groups:  timepoint:id, 1600; id, 200; Xr, 8 #>  #> Fixed effects: #>                 Estimate Std. Error z value  Pr(>|z|) #> item21             2.944     0.1903  15.473 5.249e-54 #> item22             6.319     0.5853  10.796 3.612e-27 #> s(x):loadingFx1   -1.389     0.2837  -4.897 9.733e-07 #>  #> Approximate significance of smooth terms: #>                edf Ref.df Chi.sq p-value #> s(x):loading 2.491  2.491  115.1  <2e-16 confint(mod, parm = \"lambda\") #>            2.5 %   97.5 % #> lambda1 1.612341 2.791192"},{"path":"https://lcbc-uio.github.io/galamm/articles/semiparametric.html","id":"multivariate-gaussian-model","dir":"Articles","previous_headings":"Generalized Additive Models with Factor Structures","what":"Multivariate Gaussian Model","title":"Semiparametric Latent Variable Modeling","text":"now joint analysis domain 1 domain 3, item responses conditionally normally distributed. Letting \\(\\eta_{1}\\) denote latent ability domain 1 \\(\\eta_{3}\\) denote latent ability domain 3, \\(\\lambda_{i1}\\) \\(\\lambda_{i3}\\) corresponding factor loadings \\(\\)th item measuring domain, measurement model now \\[ y_{} = \\beta_{ij} + \\lambda_{ij} \\eta_{j} + \\epsilon_{ij} ~ j=1,3 \\] avoid unnecessary complexity, assume residual standard deviation responses. vignette linear mixed models heteroscedastic residuals shows assumption can relaxed. data also simulated residual standard deviations equal, case homoscedasticity assumption satisfied. structural model, smooth term relationship latent trait x, random intercepts given timepoint within subject \\(\\zeta^{(2)}\\), given subject across timepoints \\(\\zeta^{(3)}\\). \\[ \\eta_{j} = h_{j}(x) + \\zeta_{j}^{(2)} + \\zeta_{j}^{(3)} ~j=1,3. \\] first subset cognition dataset get measurements domain 1 3, conditionally normally distributed. also create two dummy variable, domain1 domain3, need defining formulas . plot data analyzing. Spaghetti plot measurements domain 1 3. Mathematically, factor loading matrix want \\[ \\Lambda = \\begin{pmatrix} 1 & 0 \\\\ \\lambda_{12} & 0 \\\\ \\lambda_{13} & 0 \\\\ 0 & 1 \\\\ 0 & \\lambda_{22} \\\\ 0 & \\lambda_{23} \\\\ 0 & \\lambda_{24} \\end{pmatrix} \\] code, becomes: call fit model. showing results, comments probably useful. formula, first term domain represents intercept per domain. Ideally intercept per item, representing item bias, case item biases set zero simulating data, thus estimating intercept unnecessary. Next, term sl(x, k = 6, = domain, load.var = c(\"ability1\", \"ability3\")) specifies want one smooth estimated independently level factor variable domain. two levels factor variable domain, loadings ability1 ability3 applied, respectively. represent two columns loading matrix . Setting k = 6 specifies want six basis functions smooth terms. first random effects term (0 + domain1:ability1 + domain3:ability3 | id) corresponds \\(\\lambda \\zeta_{j}^{(3)}\\), specifying single term, allow level-3 random intercepts correlated. next two random effect terms (0 + domain1:ability1 | id:timepoint) (0 + domain3:ability3 | id:timepoint) correspond \\(\\lambda \\zeta_{j}^{(2)}\\), specifying independently state level-2 random intercepts uncorrelated. assumption uncorrelated random intercepts level 2 reasonable simulated data way. correlations levels allowed, simply replace three random effects terms single term (0 + domain1:ability1 + domain3:ability3 | id / timepoint). can now look model output, shows factor loadings estimated close true value, level-3 random intercepts estimated correlation 0.61 actually reasonable approximation true value 0.4, since random effect correlations notoriously hard estimate. now study smooth terms. Since case know true values, include comparison. First look smooth domain 1, see estimate well captures true value. Comparison estimate true value. Next look domain 3. case see estimate oversmoothing true value. probably number basis functions six, avoid convergence issues. case, overall shape true trajectory clearly captured. Comparison estimate true value.","code":"dat <- subset(cognition, domain %in% c(1, 3)) dat <- cbind(   dat,    model.matrix(~ 0 + domain, data = dat)[, c(\"domain1\", \"domain3\")] ) ggplot(dat, aes(x = x, y = y, group = id)) +    geom_point(size = .1) +    geom_line(linewidth = .1, alpha = .3) +   facet_wrap(     vars(item), scales = \"free_y\",     labeller = as_labeller(function(x) paste(\"Domain\", substr(x, 1, 1),                                               \"item\", substr(x, 2, 2)))) +    theme(strip.background = element_blank(),         panel.grid = element_blank()) (lmat <- matrix(c(1, NA, NA, 0, 0, 0, 0,                  0, 0, 0, 1, NA, NA, NA), ncol = 2)) #>      [,1] [,2] #> [1,]    1    0 #> [2,]   NA    0 #> [3,]   NA    0 #> [4,]    0    1 #> [5,]    0   NA #> [6,]    0   NA #> [7,]    0   NA mod <- galamm(   formula = y ~ domain +     sl(x, k = 6, by = domain, load.var = c(\"ability1\", \"ability3\")) +      (0 + domain1:ability1 + domain3:ability3 | id) +      (0 + domain1:ability1 | id:timepoint) +      (0 + domain3:ability3 | id:timepoint),   data = dat,   load.var = \"item\",   lambda = list(lmat),   factor = list(c(\"ability1\", \"ability3\")) ) summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ domain + sl(x, k = 6, by = domain, load.var = c(\"ability1\",   #>     \"ability3\")) + (0 + domain1:ability1 + domain3:ability3 |   #>     id) + (0 + domain1:ability1 | id:timepoint) + (0 + domain3:ability3 |      id:timepoint) #>    Data: dat #>  #>      AIC      BIC   logLik deviance df.resid  #>  -1319.6  -1195.1    676.8  -1353.6    11183  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #>  -10.90    5.65 1015.94 1264.17 2490.17  #>  #> Lambda: #>         ability1       SE ability3        SE #> lambda1    1.000        .        .         . #> lambda2    1.398 0.002568        .         . #> lambda3    0.302 0.002006        .         . #> lambda4        .        .   1.0000         . #> lambda5        .        .   0.9995 0.0007682 #> lambda6        .        .   1.0009 0.0007690 #> lambda7        .        .   2.0003 0.0015716 #>  #> Random effects: #>  Groups         Name                  Variance Std.Dev. Corr #>  id.timepoint   domain3:ability3       0.46249 0.6801        #>  id.timepoint.1 domain1:ability1       0.23946 0.4893        #>  id             domain1:ability1       8.70515 2.9504        #>                 domain3:ability3      18.80099 4.3360   0.61 #>  Xr.0           s(x):domain3:ability3 13.89382 3.7274        #>  Xr             s(x):domain1:ability1 16.36177 4.0450        #>  Residual                              0.01007 0.1003        #> Number of obs: 11200, groups:  id:timepoint, 1600; id, 200; Xr.0, 4; Xr, 4 #>  #> Fixed effects: #>                           Estimate Std. Error  t value Pr(>|t|) #> (Intercept)              -0.003987   0.004679  -0.8522   0.3941 #> domain3                   0.002019   0.007608   0.2654   0.7907 #> s(x):domain1:ability1Fx1  0.152050   0.118988   1.2779   0.2013 #> s(x):domain3:ability3Fx1 -9.599527   0.171067 -56.1155   0.0000 #>  #> Approximate significance of smooth terms: #>                         edf Ref.df      F p-value #> s(x):domain1:ability1 4.998  4.998   7718  <2e-16 #> s(x):domain3:ability3 4.996  4.996 101282  <2e-16 # x-values to plot the true function x <- seq(from = 0, to = 1, by = .01) # True function f0 <- function(x) 2 * sin(pi * x) # Scale to mean zero across x y <- f0(x) - mean(f0(x))  # Plot estimate plot_smooth(mod, select = 1, scale = 0) # Overlay true curve in red lines(x, y, col = \"red\") # True function f2 <- function(x) {   0.2 * x^11 * (10 * (1 - x))^6 + 10 *     (10 * x)^3 * (1 - x)^10 } # Scale to mean zero across x y <- f2(x) - mean(f2(x))  # Plot estimate plot_smooth(mod, select = 2, scale = 0) # Overlay true curve in red lines(x, y, col = \"red\")"},{"path":"https://lcbc-uio.github.io/galamm/articles/semiparametric.html","id":"multivariate-binomial-and-gaussian-model","dir":"Articles","previous_headings":"Generalized Additive Models with Factor Structures","what":"Multivariate Binomial and Gaussian Model","title":"Semiparametric Latent Variable Modeling","text":"now extend model also include items measuring domain 2, binomially distributed single trial. start adding dummy variables domain, . Next define factor loading matrix, now three columns. responses now either conditionally Gaussian conditionally binomial, define family object family mapping follows: Since model computationally challenging, need think optimization. define control object follows, trace = 3 means want optim() function relatively verbose, REPORT = 5 means want report every fifth iteration, factr = 1e9 means reduction marginal loglikelihood within \\(10^{9}\\) times machine precision, convergence occured. default factr 1e7, less strict default. Finally, reduced_hessian = TRUE means maximum marginal likelihood solution found, Hessian matrix contain partial derivatives respect fixed regression coefficients factor loadings. , contain derivatives respect variance components, models complexity typically leads non-positive definite Hessian matrices. also means Wald type confidence intervals based Hessian matrix approximate usual, since ignore uncertainty variance components. However, simulations Sørensen, Fjell, Walhovd (2023) suggest results confidence intervals still quite good parameters. example, also remove level-2 disturbances, lead computational challenges directly relevant example. real data analysis first example Sørensen, Fjell, Walhovd (2023), level-2 disturbances included model converge, necessary general drop level. summary output shown : estimated smooth terms shown plots . First smooth term semiparametric mixed response model. Second smooth term semiparametric mixed response model. Third smooth term semiparametric mixed response model.","code":"mm <- model.matrix(~ 0 + domain, data = cognition) dat <- cbind(cognition, mm) (lmat <- matrix(   c(1, NA, NA, 0, 0, 0, 0, 0, 0,     0, 0, 0, 1, NA, 0, 0, 0, 0,     0, 0, 0, 0, 0, 1, NA, NA, NA),   ncol = 3)) #>       [,1] [,2] [,3] #>  [1,]    1    0    0 #>  [2,]   NA    0    0 #>  [3,]   NA    0    0 #>  [4,]    0    1    0 #>  [5,]    0   NA    0 #>  [6,]    0    0    1 #>  [7,]    0    0   NA #>  [8,]    0    0   NA #>  [9,]    0    0   NA family <- c(gaussian, binomial) family_mapping <- ifelse(dat$domain %in% c(1, 3), 1L, 2L) control <-  galamm_control(   optim_control = list(trace = 3, REPORT = 5, factr = 1e9),   reduced_hessian = TRUE) mod <- galamm(   formula = y ~ domain +      sl(x, k = 6, by = domain,         load.var = c(\"ability1\", \"ability2\", \"ability3\")) +      (0 + domain1:ability1 + domain2:ability2 + domain3:ability3 | id),   data = dat,   family = family,   family_mapping = family_mapping,   load.var = \"item\",   lambda = list(lmat),   factor = list(c(\"ability1\", \"ability2\", \"ability3\")),   control = control ) #> N = 21, M = 20 machine precision = 2.22045e-16 #> At X0, 0 variables are exactly at the bounds #> At iterate     0  f=        25990  |proj g|=         6749 #> At iterate     5  f =        19398  |proj g|=        780.41 #> At iterate    10  f =        15323  |proj g|=        1141.7 #> At iterate    15  f =        14627  |proj g|=        1576.5 #> At iterate    20  f =        14483  |proj g|=        162.98 #> At iterate    25  f =        14397  |proj g|=         37.08 #> At iterate    30  f =        14329  |proj g|=        314.17 #> At iterate    35  f =        14260  |proj g|=        191.23 #> At iterate    40  f =        14247  |proj g|=         27.04 #> At iterate    45  f =        14242  |proj g|=        30.921 #> At iterate    50  f =        14239  |proj g|=        28.512 #> At iterate    55  f =        14237  |proj g|=        48.242 #> At iterate    60  f =        14237  |proj g|=        25.373 #> At iterate    65  f =        14236  |proj g|=        150.72 #> At iterate    70  f =        14231  |proj g|=        110.19 #> At iterate    75  f =        14230  |proj g|=        57.963 #> At iterate    80  f =        14225  |proj g|=        32.814 #> At iterate    85  f =        14224  |proj g|=        23.879 #> At iterate    90  f =        14223  |proj g|=        17.141 #> At iterate    95  f =        14220  |proj g|=        13.796 #> At iterate   100  f =        14219  |proj g|=        21.301 #> final  value 14218.761356  #> stopped after 101 iterations summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ domain + sl(x, k = 6, by = domain, load.var = c(\"ability1\",   #>     \"ability2\", \"ability3\")) + (0 + domain1:ability1 + domain2:ability2 +      domain3:ability3 | id) #>    Data: dat #> Control: control #>  #>        AIC        BIC     logLik   deviance   df.resid  #>    28481.5    28648.2   -14218.8 35771641.8      14378  #>  #> Scaled residuals:  #>      Min       1Q   Median       3Q      Max  #> -253.327   -2.731    0.058   70.749  133.839  #>  #> Lambda: #>         ability1      SE ability2    SE ability3       SE #> lambda1   1.0000       .        .     .        .        . #> lambda2   1.4005 0.01851        .     .        .        . #> lambda3   0.2986 0.01512        .     .        .        . #> lambda4        .       .    1.000     .        .        . #> lambda5        .       .    1.725 0.147        .        . #> lambda6        .       .        .     .   1.0000        . #> lambda7        .       .        .     .   0.9999 0.005676 #> lambda8        .       .        .     .   1.0007 0.005679 #> lambda9        .       .        .     .   2.0111 0.011334 #>  #> Random effects: #>  Groups Name                  Variance Std.Dev. Corr      #>  id     domain1:ability1        2.452   1.566             #>         domain2:ability2        3.646   1.909   0.86      #>         domain3:ability3       11.898   3.449   0.82 1.00 #>  Xr.1   s(x):domain3:ability3 223.339  14.945             #>  Xr.0   s(x):domain2:ability2   1.665   1.290             #>  Xr     s(x):domain1:ability1   7.465   2.732             #> Number of obs: 14400, groups:  id, 200; Xr.1, 4; Xr.0, 4; Xr, 4 #>  #> Fixed effects: #>                           Estimate Std. Error    z value  Pr(>|z|) #> (Intercept)               0.001827    0.03152    0.05796 9.538e-01 #> domain2                   0.811792    0.12790    6.34727 2.192e-10 #> domain3                   0.056704    0.04989    1.13662 2.557e-01 #> s(x):domain1:ability1Fx1  0.159995    0.10127    1.57989 1.141e-01 #> s(x):domain2:ability2Fx1 -0.337532    0.33719   -1.00103 3.168e-01 #> s(x):domain3:ability3Fx1 -9.803813    0.08146 -120.35373 0.000e+00 #>  #> Approximate significance of smooth terms: #>                         edf Ref.df       F p-value #> s(x):domain1:ability1 4.937  4.937   639.3  <2e-16 #> s(x):domain2:ability2 4.659  4.659  1714.5  <2e-16 #> s(x):domain3:ability3 4.998  4.998 16093.4  <2e-16 plot_smooth(mod, select = 1, scale = 0) plot_smooth(mod, select = 2, scale = 0) plot_smooth(mod, select = 3, scale = 0)"},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Øystein Sørensen. Author, maintainer. Douglas Bates. Contributor. Ben Bolker. Contributor. Martin Maechler. Contributor. Allan Leal. Contributor. Fabian Scheipl. Contributor. Steven Walker. Contributor. Simon Wood. Contributor.","code":""},{"path":"https://lcbc-uio.github.io/galamm/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sørensen Ø, Walhovd K, Fjell (2023). “Longitudinal Modeling Age-Dependent Latent Traits Generalized Additive Latent Mixed Models.” Psychometrika, 88(2), 456-486. doi:10.1007/s11336-023-09910-z.","code":"@Article{,   title = {Longitudinal Modeling of Age-Dependent Latent Traits with Generalized Additive Latent and Mixed Models},   author = {{\\O}ystein S{\\o}rensen and Kristine B. Walhovd and Anders M. Fjell},   journal = {Psychometrika},   year = {2023},   volume = {88},   number = {2},   pages = {456-486},   doi = {10.1007/s11336-023-09910-z}, }"},{"path":"https://lcbc-uio.github.io/galamm/index.html","id":"generalized-additive-latent-and-mixed-models-","dir":"","previous_headings":"","what":"Generalized Additive Latent and Mixed Models","title":"Generalized Additive Latent and Mixed Models","text":"galamm estimates generalized additive latent mixed models (GALAMMs). model framework computational algorithms introduced Sørensen, Fjell, Walhovd (2023), freely available Psychometrika. extension GLLAMM framework multilevel latent variable modeling detailed Rabe-Hesketh, Skrondal, Pickles (2004) Skrondal Rabe-Hesketh (2004), particular efficiently handling crossed random effects semiparametric estimation.","code":""},{"path":"https://lcbc-uio.github.io/galamm/index.html","id":"what-can-the-package-do","dir":"","previous_headings":"","what":"What Can the Package Do?","title":"Generalized Additive Latent and Mixed Models","text":"Many applications, particularly social sciences, require modeling capabilities beyond easily supported computationally feasible popular R packages like mgcv (Wood 2017), lavaan (Rosseel 2012), lme4 (Bates et al. 2015), OpenMx (Neale et al. 2016), well Stata based GLLAMM software (Rabe-Hesketh, Skrondal, Pickles 2004, 2005). particular, maximally utilize large datasets available today, typically necessary combine tools latent variable modeling, hierarchical modeling, semiparametric estimation. possible Bayesian hierarchical models tools like Stan, requires considerable expertise may beyond scope single data analysis project. goal galamm enable estimation models arbitrary number grouping levels, crossed hierarchical, combination following features (click links go relevant vignette): Linear mixed models factor structures. Generalized linear mixed models factor structures. Linear mixed models heteroscedastic residuals. Mixed models mixed response types. Generalized additive mixed models factor structures. Interactions latent observed covariates. Random effects defined using lme4 syntax, syntax factor structures close PLmixed (Rockwood Jeon 2019). However, types models supported PLmixed galamm, galamm usually considerably faster. Smooth terms, generalized additive mixed models, use syntax mgcv. users, necessary think actual computations performed, although detailed optimization vignette. short, core computations done using sparse matrix methods supported RcppEigen (Bates Eddelbuettel 2013) automatic differentiation using C++ library autodiff (Leal 2018).","code":""},{"path":"https://lcbc-uio.github.io/galamm/index.html","id":"where-do-i-start","dir":"","previous_headings":"","what":"Where Do I Start?","title":"Generalized Additive Latent and Mixed Models","text":"get started, take look introductory vignette.","code":""},{"path":"https://lcbc-uio.github.io/galamm/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Generalized Additive Latent and Mixed Models","text":"can install development version galamm GitHub :","code":"# install.packages(\"remotes\") remotes::install_github(\"LCBC-UiO/galamm\")"},{"path":"https://lcbc-uio.github.io/galamm/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Generalized Additive Latent and Mixed Models","text":"","code":"library(galamm)"},{"path":"https://lcbc-uio.github.io/galamm/index.html","id":"mixed-response-model","dir":"","previous_headings":"Examples","what":"Mixed Response Model","title":"Generalized Additive Latent and Mixed Models","text":"dataframe mresp contains simulated data mixed response types. Responses rows itemgroup = \"\" normally distributed rows itemgroup = \"b\" binomially distributed. given subject, identified id variable, responses associated underlying latent variable. hence need model process jointly, model set follows: summary function gives information model fit.","code":"head(mresp) #>   id         x          y itemgroup #> 1  1 0.8638214  0.2866329         a #> 2  1 0.7676133  2.5647490         a #> 3  1 0.8812059  1.0000000         b #> 4  1 0.2239725  1.0000000         b #> 5  2 0.7215696 -0.4721698         a #> 6  2 0.6924851  1.1750286         a mixed_resp <- galamm(   formula = y ~ x + (0 + loading | id),   data = mresp,   family = c(gaussian, binomial),   family_mapping = ifelse(mresp$itemgroup == \"a\", 1L, 2L),   load.var = \"itemgroup\",   lambda = list(matrix(c(1, NA), ncol = 1)),   factor = list(\"loading\") ) summary(mixed_resp) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ x + (0 + loading | id) #>    Data: mresp #>  #>      AIC      BIC   logLik deviance df.resid  #>   9248.7   9280.2  -4619.3   3633.1     3995  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -3.5360 -0.7078  0.2156  0.6456  2.5978  #>  #> Lambda: #>         loading      SE #> lambda1   1.000       . #> lambda2   1.095 0.09982 #>  #> Random effects: #>  Groups Name    Variance Std.Dev. #>  id     loading 1.05     1.025    #> Number of obs: 4000, groups:  id, 1000 #>  #> Fixed effects: #>             Estimate Std. Error z value  Pr(>|z|) #> (Intercept)    0.041    0.05803  0.7065 4.799e-01 #> x              0.971    0.08594 11.2994 1.321e-29"},{"path":"https://lcbc-uio.github.io/galamm/index.html","id":"generalized-additive-mixed-model-with-factor-structures","dir":"","previous_headings":"Examples","what":"Generalized Additive Mixed Model with Factor Structures","title":"Generalized Additive Latent and Mixed Models","text":"dataframe cognition contains simulated latent ability three cognitive domains measured across time. focus first cognitive domain, estimate smooth trajectory latent ability depends time. start reducing data. Next define matrix factor loadings, NA denotes unknown values estimated. compute model estimates, containing smooth term latent ability random intercept subject timepoints. finally plot estimated smooth term.","code":"dat <- subset(cognition, domain == 1) dat$item <- factor(dat$item) loading_matrix <- matrix(c(1, NA, NA), ncol = 1) mod <- galamm(   formula = y ~ 0 + item + sl(x, load.var = \"loading\") +     (0 + loading | id / timepoint),   data = dat,   load.var = \"item\",   lambda = list(loading_matrix),   factor = list(\"loading\") ) plot_smooth(mod)"},{"path":"https://lcbc-uio.github.io/galamm/index.html","id":"how-to-cite-this-package","dir":"","previous_headings":"","what":"How to cite this package","title":"Generalized Additive Latent and Mixed Models","text":"","code":"citation(\"galamm\") #> To cite package 'galamm' in publications use: #>  #>   Sørensen Ø, Walhovd K, Fjell A (2023). \"Longitudinal Modeling of #>   Age-Dependent Latent Traits with Generalized Additive Latent and #>   Mixed Models.\" _Psychometrika_, *88*(2), 456-486. #>   doi:10.1007/s11336-023-09910-z #>   <https://doi.org/10.1007/s11336-023-09910-z>. #>  #> A BibTeX entry for LaTeX users is #>  #>   @Article{, #>     title = {Longitudinal Modeling of Age-Dependent Latent Traits with Generalized Additive Latent and Mixed Models}, #>     author = {{\\O}ystein S{\\o}rensen and Kristine B. Walhovd and Anders M. Fjell}, #>     journal = {Psychometrika}, #>     year = {2023}, #>     volume = {88}, #>     number = {2}, #>     pages = {456-486}, #>     doi = {10.1007/s11336-023-09910-z}, #>   }"},{"path":"https://lcbc-uio.github.io/galamm/index.html","id":"acknowledgement","dir":"","previous_headings":"","what":"Acknowledgement","title":"Generalized Additive Latent and Mixed Models","text":"parts code base galamm derived internal functions R packages, gamm4 (authors: Simon Wood Fabian Scheipl), lme4 (authors: Douglas Bates, Martin Maechler, Ben Bolker, Steven Walker), mgcv (author: Simon Wood), well C++ library autodiff (author: Allan Leal). accordance CRAN Repository Policy, authors listed contributors DESCRIPTION file. among authors, don’t want listed contributor package, please let know, remove .","code":""},{"path":"https://lcbc-uio.github.io/galamm/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Generalized Additive Latent and Mixed Models","text":"Contributions welcome, see CONTRIBUTING.md general guidelines.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/news.html","id":null,"dir":"","previous_headings":"","what":"galamm version 0.1.0","title":"galamm version 0.1.0","text":"Initial version.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/VarCorr.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract variance and correlation components from model — VarCorr","title":"Extract variance and correlation components from model — VarCorr","text":"Extract variance correlation components model","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/VarCorr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract variance and correlation components from model — VarCorr","text":"","code":"# S3 method for galamm VarCorr(x, sigma = 1, ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/VarCorr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract variance and correlation components from model — VarCorr","text":"x object class galamm returned galamm. sigma Numeric value used multiple standard deviations. Defaults 1. ... arguments passed onto methods. Currently used.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/VarCorr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract variance and correlation components from model — VarCorr","text":"object class VarCorr.galamm.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/VarCorr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract variance and correlation components from model — VarCorr","text":"","code":"# Linear mixed model with heteroscedastic residuals mod <- galamm(   formula = y ~ x + (1 | id),   weights = ~ (1 | item),   data = hsced )  # Extract information on variance and covariance VarCorr(mod) #>  Groups   Name        Std.Dev. Variance #>  id       (Intercept) 0.99400  0.98804  #>  Residual             0.97964  0.95970"},{"path":"https://lcbc-uio.github.io/galamm/reference/anova.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare likelihoods of galamm objects — anova.galamm","title":"Compare likelihoods of galamm objects — anova.galamm","text":"Anova function comparing different GALAMMs fitted data.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/anova.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare likelihoods of galamm objects — anova.galamm","text":"","code":"# S3 method for galamm anova(object, ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/anova.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare likelihoods of galamm objects — anova.galamm","text":"object object class galamm returned galamm. ... fitted models class galamm. Currently, models provided argument, table returned.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/anova.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare likelihoods of galamm objects — anova.galamm","text":"table model comparison metric.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/anova.galamm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compare likelihoods of galamm objects — anova.galamm","text":"Bates DM, Mächler M, Bolker B, Walker S (2015). “Fitting Linear Mixed-Effects Models Using Lme4.” Journal Statistical Software, 67(1), 1--48. ISSN 1548-7660, doi:10.18637/jss.v067.i01 .","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/anova.galamm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compare likelihoods of galamm objects — anova.galamm","text":"source code function adapted lme4:::anova.merMod, authors Douglas M. Bates, Martin Maechler, Ben Bolker, Steve Walker.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/anova.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare likelihoods of galamm objects — anova.galamm","text":"","code":"# Poisson GLMM count_mod <- galamm(   formula = y ~ lbas * treat + lage + v4 + (1 | subj),   data = epilep, family = poisson )  # Model without interaction count_mod0 <- galamm(   formula = y ~ lbas + treat + lage + v4 + (1 | subj),   data = epilep, family = poisson )  # Model comparison anova(count_mod, count_mod0) #> Data: epilep #> Models: #> count_mod0: y ~ lbas + treat + lage + v4 + (1 | subj) #> count_mod: y ~ lbas * treat + lage + v4 + (1 | subj) #>            npar    AIC    BIC  logLik deviance  Chisq Df Pr(>Chisq)   #> count_mod0    6 1345.4 1366.2 -666.72   407.01                        #> count_mod     7 1344.7 1369.0 -665.36   407.01 2.7208  1    0.09905 . #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1"},{"path":"https://lcbc-uio.github.io/galamm/reference/coef.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract galamm coefficients — coef.galamm","title":"Extract galamm coefficients — coef.galamm","text":"Currently, function returns fixed effects.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/coef.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract galamm coefficients — coef.galamm","text":"","code":"# S3 method for galamm coef(object, ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/coef.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract galamm coefficients — coef.galamm","text":"object object class galamm, galamm. ... Additional parameters passed methods. Currently used.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/coef.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract galamm coefficients — coef.galamm","text":"matrix requested coefficients.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/coef.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract galamm coefficients — coef.galamm","text":"","code":"# Poisson GLMM count_mod <- galamm(   formula = y ~ lbas * treat + lage + v4 + (1 | subj),   data = epilep, family = poisson )  # Extract coefficients coef(count_mod) #> (Intercept)        lbas       treat        lage          v4  lbas:treat  #>   1.7935692   0.8845040  -0.3349626   0.4845851  -0.1610874   0.3383899"},{"path":"https://lcbc-uio.github.io/galamm/reference/cognition.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated Data with Measurements of Cognitive Abilities — cognition","title":"Simulated Data with Measurements of Cognitive Abilities — cognition","text":"Simulated dataset mimicking measurement abilities three cognitive domains. latent traits (cognitive ability given domain) based functions mgcv::gamSim (Wood 2017) , depend explanatory variable x.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/cognition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated Data with Measurements of Cognitive Abilities — cognition","text":"","code":"cognition"},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/cognition.html","id":"cognition-a-data-frame-with-rows-and-columns-","dir":"Reference","previous_headings":"","what":"cognition A data frame with 14400 rows and 7 columns:","title":"Simulated Data with Measurements of Cognitive Abilities — cognition","text":"id Subject ID. domain Factor variable denoting cognitive domain. x Explanatory variable. timepoint Factor variable denoting timepoint. item Factor variable denoting item within tests cognitive domain. trials Number trials, applicable. y Response variable. domain 1 real number, domain 2 binomially distributed variable based single trial, domain 3 real number.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/cognition.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulated Data with Measurements of Cognitive Abilities — cognition","text":"Wood SN (2017). Generalized Additive Models: Introduction R, 2 edition. Chapman Hall/CRC.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/confint.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Confidence intervals for model parameters — confint.galamm","title":"Confidence intervals for model parameters — confint.galamm","text":"Confidence intervals model parameters","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/confint.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Confidence intervals for model parameters — confint.galamm","text":"","code":"# S3 method for galamm confint(object, parm, level = 0.95, method = \"Wald\", ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/confint.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Confidence intervals for model parameters — confint.galamm","text":"object object class galamm returned galamm. parm Parameters compute intervals. Use \"theta\" get variance parameters, \"beta\" get fixed regression coefficients, \"lambda\" get factor loadings, \"weights\" get weights. parameter can also given numeric vector indices specifying parameters. level Confidence level. Defaults 0.95. method Currently \"Wald\" available. ... arguments passed methods. Currently used.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/confint.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Confidence intervals for model parameters — confint.galamm","text":"matrix requested confidence intervals.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/confint.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Confidence intervals for model parameters — confint.galamm","text":"","code":"# Poisson GLMM count_mod <- galamm(   formula = y ~ lbas * treat + lage + v4 + (1 | subj),   data = epilep, family = poisson )  confint(count_mod, parm = \"beta\", level = .99) #>                  0.5 %      99.5 % #> (Intercept)  1.5239392  2.06319914 #> lbas         0.5471847  1.22182317 #> treat       -0.7155511  0.04562592 #> lage        -0.4081356  1.37730585 #> v4          -0.3016653 -0.02050959 #> lbas:treat  -0.1843249  0.86110474"},{"path":"https://lcbc-uio.github.io/galamm/reference/deviance.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract deviance of galamm object — deviance.galamm","title":"Extract deviance of galamm object — deviance.galamm","text":"Extract deviance galamm object","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/deviance.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract deviance of galamm object — deviance.galamm","text":"","code":"# S3 method for galamm deviance(object, ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/deviance.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract deviance of galamm object — deviance.galamm","text":"object Object class galamm, returned galamm. ... arguments passed methods. Currently used.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/deviance.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract deviance of galamm object — deviance.galamm","text":"numeric value giving deviance model fit.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/deviance.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract deviance of galamm object — deviance.galamm","text":"","code":"# Linear mixed model with heteroscedastic residuals mod <- galamm(   formula = y ~ x + (1 | id),   weights = ~ (1 | item),   data = hsced )  # Extract deviance deviance(mod) #> [1] 4116.28"},{"path":"https://lcbc-uio.github.io/galamm/reference/diet.html","id":null,"dir":"Reference","previous_headings":"","what":"Diet Data — diet","title":"Diet Data — diet","text":"Longitudinal epilepsy data Morris et al. (1977) . documentation based Chapter 14.2 Skrondal Rabe-Hesketh (2004) , dataset used. See also Rabe-Hesketh et al. (2003) .","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/diet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diet Data — diet","text":"","code":"diet"},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/diet.html","id":"diet-a-data-frame-with-rows-and-columns-","dir":"Reference","previous_headings":"","what":"diet A data frame with 236 rows and 7 columns:","title":"Diet Data — diet","text":"id Subject ID. age Age (standardized). bus Dummy variable indicating whether subject bus driver banking staff. item Integer indicating whether outcome fiber intake time 1 (item = 1), fiber intake time 2 (item = 2), coronary heart disease (item = 3). y Outcome. chd Dummy variable indicating whether y indicator coronary heart disease, coded 0/1. fiber Dummy variable indicating whether y fiber measurement either timepoint 1 2. fiber2 Dummy variable indicating whether y fiber measurement timepoint 2.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/diet.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Diet Data — diet","text":"http://www.gllamm.org/books/readme.html#14.2","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/diet.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Diet Data — diet","text":"Morris JN, Marr JW, Clayton DG (1977). “Diet Heart: Postscript.” Br Med J, 2(6098), 1307--1314. ISSN 0007-1447, 1468-5833, doi:10.1136/bmj.2.6098.1307 . Rabe-Hesketh S, Pickles , Skrondal (2003). “Correcting Covariate Measurement Error Logistic Regression Using Nonparametric Maximum Likelihood Estimation.” Statistical Modelling, 3(3), 215--232. ISSN 1471-082X, doi:10.1191/1471082X03st056oa . Skrondal , Rabe-Hesketh S (2004). Generalized Latent Variable Modeling,  Interdisciplinary Statistics Series. Chapman Hall/CRC, Boca Raton, Florida.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/epilep.html","id":null,"dir":"Reference","previous_headings":"","what":"Epilepsy Data — epilep","title":"Epilepsy Data — epilep","text":"Longitudinal epilepsy data Leppik et al. (1987) . documentation based Chapter 11.3 Skrondal Rabe-Hesketh (2004) , dataset used.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/epilep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Epilepsy Data — epilep","text":"","code":"epilep"},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/epilep.html","id":"epilep-a-data-frame-with-rows-and-columns-","dir":"Reference","previous_headings":"","what":"epilep A data frame with 236 rows and 7 columns:","title":"Epilepsy Data — epilep","text":"subj Subject ID. y Number seizures. treat Dummy variable treatment group. visit Time visit. v4 Dummy visit 4. lage Logarithm age. lbas Logarithm quarter number seizures eight weeks preceding entry trial.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/epilep.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Epilepsy Data — epilep","text":"http://www.gllamm.org/books/readme.html#11.3","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/epilep.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Epilepsy Data — epilep","text":"Leppik IE, Dreifuss FE, Porter R, Bowman T, Santilli N, Jacobs M, Crosby C, Cloyd J, Stackman J, Graves N, Sutula T, Welty T, Vickery J, Brundage R, Gates J, Gumnit RJ, Gutierrez (1987). “Controlled Study Progabide Partial Seizures: Methodology Results.” Neurology, 37(6), 963--963. ISSN 0028-3878, 1526-632X, doi:10.1212/WNL.37.6.963 . Skrondal , Rabe-Hesketh S (2004). Generalized Latent Variable Modeling,  Interdisciplinary Statistics Series. Chapman Hall/CRC, Boca Raton, Florida.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/extract_optim_parameters.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract parameters from fitted model for use as initial values — extract_optim_parameters.galamm","title":"Extract parameters from fitted model for use as initial values — extract_optim_parameters.galamm","text":"function extracts parameter values fitted model object form can directly provided initial values new model fit.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/extract_optim_parameters.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract parameters from fitted model for use as initial values — extract_optim_parameters.galamm","text":"","code":"# S3 method for galamm extract_optim_parameters(object)"},{"path":"https://lcbc-uio.github.io/galamm/reference/extract_optim_parameters.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract parameters from fitted model for use as initial values — extract_optim_parameters.galamm","text":"object Object class galamm returned galamm.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/extract_optim_parameters.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract parameters from fitted model for use as initial values — extract_optim_parameters.galamm","text":"list object containing following elements: theta Numerical vector variance components, .e., entries lower Cholesky form covariance matrix random effects. beta Fixed regression coefficients. lambda Factor loadings. weights Weights heteroscedastic residuals.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/extract_optim_parameters.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract parameters from fitted model for use as initial values — extract_optim_parameters.galamm","text":"","code":"# Fit linear mixed model with heteroscedastic residuals mod <- galamm(   formula = y ~ x + (1 | id),   weights = ~ (1 | item),   data = hsced )  # Extract parameters start <- extract_optim_parameters(mod)  # Fit again using the Nelder-Mead algorithm, using start as initial values: mod_nm <- galamm(   formula = y ~ x + (1 | id),   weights = ~ (1 | item),   data = hsced,   start = start,   control = galamm_control(method = \"Nelder-Mead\") )"},{"path":"https://lcbc-uio.github.io/galamm/reference/factor_loadings.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract factor loadings from galamm object — factor_loadings.galamm","title":"Extract factor loadings from galamm object — factor_loadings.galamm","text":"Extract factor loadings galamm object","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/factor_loadings.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract factor loadings from galamm object — factor_loadings.galamm","text":"","code":"# S3 method for galamm factor_loadings(object)"},{"path":"https://lcbc-uio.github.io/galamm/reference/factor_loadings.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract factor loadings from galamm object — factor_loadings.galamm","text":"object Object class galamm returned galamm.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/factor_loadings.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract factor loadings from galamm object — factor_loadings.galamm","text":"matrix containing estimated factor loadings corresponding standard deviations.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/factor_loadings.galamm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract factor loadings from galamm object — factor_loadings.galamm","text":"function named factor_loadings rather just loadings avoid conflict stats::loadings.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/factor_loadings.galamm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract factor loadings from galamm object — factor_loadings.galamm","text":"example function comes PLmixed, authors Nicholas Rockwood Minjeong Jeon (Rockwood Jeon 2019) .","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/factor_loadings.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract factor loadings from galamm object — factor_loadings.galamm","text":"","code":"# Logistic mixed model with factor loadings, example from PLmixed data(\"IRTsim\", package = \"PLmixed\")  # Reduce data size for the example to run faster IRTsub <- IRTsim[IRTsim$item < 4, ] IRTsub <- IRTsub[sample(nrow(IRTsub), 300), ] IRTsub$item <- factor(IRTsub$item)  # Fix loading for first item to 1, and estimate the two others freely loading_matrix <- matrix(c(1, NA, NA), ncol = 1)  # Estimate model mod <- galamm(y ~ item + (0 + ability | sid) + (0 + ability | school),   data = IRTsub, family = binomial, load.var = \"item\",   factor = list(\"ability\"), lambda = list(loading_matrix) )  # Show estimated factor loadings, with standard errors factor_loadings(mod) #>           ability       SE #> lambda1 1.0000000       NA #> lambda2 0.6296361 0.290343 #> lambda3 1.2664388 0.482234"},{"path":"https://lcbc-uio.github.io/galamm/reference/family.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract family or families from fitted galamm — family.galamm","title":"Extract family or families from fitted galamm — family.galamm","text":"function returns list families object class galamm, returned galamm.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/family.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract family or families from fitted galamm — family.galamm","text":"","code":"# S3 method for galamm family(object, ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/family.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract family or families from fitted galamm — family.galamm","text":"object object class galamm. ... Optional arguments. Currently used.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/family.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract family or families from fitted galamm — family.galamm","text":"list family objects.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/family.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract family or families from fitted galamm — family.galamm","text":"","code":"# Mixed response model loading_matrix <- matrix(c(1, NA), ncol = 1) families <- c(gaussian, binomial) family_mapping <- ifelse(mresp$itemgroup == \"a\", 1, 2)  mixed_resp <- galamm(   formula = y ~ x + (0 + level | id),   data = mresp,   family = families,   family_mapping = family_mapping,   load.var = \"itemgroup\",   lambda = list(loading_matrix),   factor = list(\"level\") )  # This model has two family objects family(mixed_resp) #> [[1]] #>  #> Family: gaussian  #> Link function: identity  #>  #>  #> [[2]] #>  #> Family: binomial  #> Link function: logit  #>  #>"},{"path":"https://lcbc-uio.github.io/galamm/reference/fitted.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract model fitted values — fitted.galamm","title":"Extract model fitted values — fitted.galamm","text":"Extract model fitted values","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/fitted.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract model fitted values — fitted.galamm","text":"","code":"# S3 method for galamm fitted(object, ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/fitted.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract model fitted values — fitted.galamm","text":"object object class galamm returned galamm. ... Optional arguments passed methods. Currently used.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/fitted.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract model fitted values — fitted.galamm","text":"numerical vector fit values row input data.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/fitted.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract model fitted values — fitted.galamm","text":"","code":"# Linear mixed model with heteroscedastic residuals mod <- galamm(   formula = y ~ x + (1 | id),   weights = ~ (1 | item),   data = hsced )  # Extract fitted values and plot against x plot(hsced$x, fitted(mod))"},{"path":"https://lcbc-uio.github.io/galamm/reference/fixef.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract fixed effects from galamm objects — fixef","title":"Extract fixed effects from galamm objects — fixef","text":"Extract fixed regression coefficients.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/fixef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract fixed effects from galamm objects — fixef","text":"","code":"# S3 method for galamm fixef(object, ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/fixef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract fixed effects from galamm objects — fixef","text":"object object class galamm, returned galamm. ... Optional parameters passed functions. Currently used.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/fixef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract fixed effects from galamm objects — fixef","text":"matrix requested fixed effects.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/fixef.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract fixed effects from galamm objects — fixef","text":"","code":"# Poisson GLMM count_mod <- galamm(   formula = y ~ lbas * treat + lage + v4 + (1 | subj),   data = epilep, family = poisson )  # Extract fixed effects fixef(count_mod) #> (Intercept)        lbas       treat        lage          v4  lbas:treat  #>   1.7935692   0.8845040  -0.3349626   0.4845851  -0.1610874   0.3383899"},{"path":"https://lcbc-uio.github.io/galamm/reference/galamm-package.html","id":null,"dir":"Reference","previous_headings":"","what":"galamm: Generalized Additive Latent and Mixed Models — galamm-package","title":"galamm: Generalized Additive Latent and Mixed Models — galamm-package","text":"Estimates generalized additive latent mixed models using maximum marginal likelihood, defined Sorensen et al. (2023) doi:10.1007/s11336-023-09910-z , extension Rabe-Hesketh Skrondal (2004)'s unifying framework multilevel latent variable modeling doi:10.1007/BF02295939 . Efficient computation done using sparse matrix methods, Laplace approximation, automatic differentiation. framework includes generalized multilevel models heteroscedastic residuals, mixed response types, factor loadings, smoothing splines, crossed random effects, combinations thereof. Syntax model formulation close 'lme4' (Bates et al. (2015) doi:10.18637/jss.v067.i01 ) 'PLmixed' (Rockwood Jeon (2019) doi:10.1080/00273171.2018.1516541 ).","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/galamm-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"galamm: Generalized Additive Latent and Mixed Models — galamm-package","text":"Sørensen Ø, Fjell , Walhovd KB (2023). “Longitudinal Modeling Age-Dependent Latent Traits Generalized Additive Latent Mixed Models.” Psychometrika, 88(2), 456--486. ISSN 1860-0980, doi:10.1007/s11336-023-09910-z .","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/galamm-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"galamm: Generalized Additive Latent and Mixed Models — galamm-package","text":"Maintainer: Øystein Sørensen oystein.sorensen@psykologi.uio.(ORCID) contributors: Douglas Bates [contributor] Ben Bolker [contributor] Martin Maechler [contributor] Allan Leal [contributor] Fabian Scheipl [contributor] Steven Walker [contributor] Simon Wood [contributor]","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a generalized additive latent and mixed model — galamm","title":"Fit a generalized additive latent and mixed model — galamm","text":"function fits generalized additive latent mixed model (GALAMMs), described Sørensen et al. (2023) . building blocks models generalized additive mixed models (GAMMs) (Wood 2017) , generalized linear mixed models (Breslow Clayton 1993; Harville 1977; Henderson 1975; Laird Ware 1982)  special cases. GALAMMs extend upon GAMMs allowing factor structures, commonly used model hypothesized latent traits underlying observed measurements. sense, GALAMMs extension generalized linear latent mixed models (GLLAMMs) (Skrondal Rabe-Hesketh 2004; Rabe-Hesketh et al. 2004)  allows semiparametric estimation. implemented algorithm used compute model estimates described Sørensen et al. (2023) , extension algorithm used fitting generalized linear mixed models lme4 package (Bates et al. 2015) . syntax used define factor structures based used PLmixed package, detailed Rockwood Jeon (2019) .","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a generalized additive latent and mixed model — galamm","text":"","code":"galamm(   formula,   weights = NULL,   data,   family = gaussian,   family_mapping = rep(1L, nrow(data)),   load.var = NULL,   lambda = NULL,   factor = NULL,   factor_interactions = NULL,   start = NULL,   control = galamm_control() )"},{"path":"https://lcbc-uio.github.io/galamm/reference/galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a generalized additive latent and mixed model — galamm","text":"formula formula specifying model. Smooth terms defined style mgcv gamm4 packages, see (Wood 2017)  introduction. Random effects specified using lme4 syntax, described detail (Bates et al. 2015) . Factor loadings also part model formula, based syntax PLmixed package (Rockwood Jeon 2019) . weights optional formula object specifying expression residual variance. Defaults NULL, corresponding homoscedastic errors. formula defined lme4 style; see vignettes examples details. data dataset containing variables specified model formula, exception factor loadings. family vector containing one model families. element family corresponding element family_mapping specifying elements response conditionally distributed according given family. Currently family can one gaussian, binomial, poisson, canonical link functions supported. family_mapping Optional vector mapping elements family rows data. Defaults rep(1L,   nrow(data)), means observations distributed according first element family. load.var Optional character specifying name variable data identifying factors load onto. , unique value load.var corresponds unique factor loading. Currently single loading supported. Default NULL, means loading variables. lambda Optional list factor loading matrices. Numerical values indicate given value fixed, NA means entry parameter estimated. Defaults NULL, means factor loading matrices. factor Optional list character vectors identical factor loadings specified formula. list element, \\(j\\)th entry character vector corresponds \\(j\\)th column corresponding matrix lambda. Defaults NULL, means factor loadings. factor_interactions Optional list length equal list provided factor argument. provided, element lists list length equal number columns corresponding matrix provided lambda argument. list element formula object containing write-hand side regression model, form ~ x + z. Defaults NULL, means factor interactions used. start Optional named list starting values parameters. Possible names list elements \"theta\", \"beta\", \"lambda\", \"weights\", numerical vectors starting values. Default NULL, means relatively sensible defaults used. control Optional control object optimization procedure class galamm_control resulting calling galamm_control. Defaults NULL, means defaults galamm_control used.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a generalized additive latent and mixed model — galamm","text":"model object class galamm, containing following elements: call matched call used fitting model. random_effects list containing following two elements: b random effects original parametrization. u random effects standardized identity covariance matrix. model list various elements related model setup fit: deviance deviance final model. deviance_residuals deviance residuals final model. df degrees freedom model. family list one family objects, specified family arguments galamm. factor_interactions List formulas specifying interactions latent observed variables, provided argument factor_interactions galamm. provided, NULL. fit numeric vector fitted values. hessian Hessian matrix final model, .e., second derivative log-likelihood respect model parameters. lmod Linear model object returned lme4::lFormula, used internally setting models. loglik Log-likelihood final model. n Number observations. pearson_residual Pearson residuals final model. reduced_hessian Logical specifying whether full Hessian matrix computed, Hessian matrix derivatives respect beta lambda. response numeric vector containing response values used fitting model. weights_object Object weights used model fitting. NULL weights used. parameters list object model parameters related information: beta_inds Integer vector specifying indices fixed regression coefficients among estimated model parameters. dispersion_parameter One dispersion parameters final model. lambda_dummy Dummy matrix factor loadings, shows structure loading matrix supplied lambda arguments. lambda_inds Integer vector specifying indices factor loadings among estimated model parameters. lambda_interaction_inds Integer vector specifying indices regression coefficients interactions latent observed variables. parameter_estimates Numeric vector final parameter estimates. parameter_names Names parameters estimates. theta_inds Integer vector specifying indices variance components among estimated model parameters. Technically entries Cholesky decomposition covariance matrix. weights_inds Integer vector specifying indices estimated weights (used heteroscedastic Gaussian models) among estimated model parameters. gam List containing information smooth terms model. smooth terms contained model, list length zero.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/galamm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fit a generalized additive latent and mixed model — galamm","text":"Bates DM, Mächler M, Bolker B, Walker S (2015). “Fitting Linear Mixed-Effects Models Using Lme4.” Journal Statistical Software, 67(1), 1--48. ISSN 1548-7660, doi:10.18637/jss.v067.i01 . Breslow NE, Clayton DG (1993). “Approximate Inference Generalized Linear Mixed Models.” Journal American Statistical Association, 88(421), 9--25. ISSN 0162-1459, doi:10.2307/2290687 . Harville DA (1977). “Maximum Likelihood Approaches Variance Component Estimation Related Problems.” Journal American Statistical Association, 72(358), 320--338. ISSN 0162-1459, doi:10.2307/2286796 . Henderson CR (1975). “Best Linear Unbiased Estimation Prediction Selection Model.” Biometrics, 31(2), 423--447. ISSN 0006-341X, doi:10.2307/2529430 . Laird NM, Ware JH (1982). “Random-Effects Models Longitudinal Data.” Biometrics, 38(4), 963--974. ISSN 0006-341X, doi:10.2307/2529876 . Rabe-Hesketh S, Skrondal , Pickles (2004). “Generalized Multilevel Structural Equation Modeling.” Psychometrika, 69(2), 167--190. ISSN 1860-0980, doi:10.1007/BF02295939 . Rockwood NJ, Jeon M (2019). “Estimating Complex Measurement Growth Models Using R Package PLmixed.” Multivariate Behavioral Research, 54(2), 288--306. ISSN 0027-3171, doi:10.1080/00273171.2018.1516541 . Skrondal , Rabe-Hesketh S (2004). Generalized Latent Variable Modeling,  Interdisciplinary Statistics Series. Chapman Hall/CRC, Boca Raton, Florida. Sørensen Ø, Fjell , Walhovd KB (2023). “Longitudinal Modeling Age-Dependent Latent Traits Generalized Additive Latent Mixed Models.” Psychometrika, 88(2), 456--486. ISSN 1860-0980, doi:10.1007/s11336-023-09910-z . Wood SN (2017). Generalized Additive Models: Introduction R, 2 edition. Chapman Hall/CRC.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a generalized additive latent and mixed model — galamm","text":"","code":"# Mixed response model ------------------------------------------------------  # The mresp dataset contains a mix of binomial and Gaussian responses.  # We need to estimate a factor loading which scales the two response types. loading_matrix <- matrix(c(1, NA), ncol = 1)  # Define mapping to families. families <- c(gaussian, binomial) family_mapping <- ifelse(mresp$itemgroup == \"a\", 1, 2)   # Fit the model mod <- galamm(   formula = y ~ x + (0 + level | id),   data = mresp,   family = families,   family_mapping = family_mapping,   factor = list(\"level\"),   load.var = \"itemgroup\",   lambda = list(loading_matrix) )  # Summary information summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ x + (0 + level | id) #>    Data: mresp #>  #>      AIC      BIC   logLik deviance df.resid  #>   9248.7   9280.2  -4619.3   3633.1     3995  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -3.5360 -0.7078  0.2156  0.6456  2.5978  #>  #> Lambda: #>         level      SE #> lambda1 1.000       . #> lambda2 1.095 0.09982 #>  #> Random effects: #>  Groups Name  Variance Std.Dev. #>  id     level 1.05     1.025    #> Number of obs: 4000, groups:  id, 1000 #>  #> Fixed effects: #>             Estimate Std. Error z value  Pr(>|z|) #> (Intercept)    0.041    0.05803  0.7065 4.799e-01 #> x              0.971    0.08594 11.2994 1.321e-29 #>  #>    # Heteroscedastic model ----------------------------------------------------- # Residuals allowed to differ according to the item variable # We also set the initial value of the random intercept standard deviation # to 1 mod <- galamm(   formula = y ~ x + (1 | id), weights = ~ (1 | item),   data = hsced, start = list(theta = 1) ) summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ x + (1 | id) #>    Data: hsced #> Weights: ~(1 | item) #>  #>      AIC      BIC   logLik deviance df.resid  #>   4126.3   4151.7  -2058.1   4116.3     1195  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -5.6545 -0.7105  0.0286  0.6827  4.3261  #>  #> Random effects: #>  Groups   Name        Variance Std.Dev. #>  id       (Intercept) 0.9880   0.9940   #>  Residual             0.9597   0.9796   #> Number of obs: 1200, groups:  id, 200 #>  #> Variance function: #>     1     2  #> 1.000 1.995  #>  #> Fixed effects: #>             Estimate Std. Error t value  Pr(>|t|) #> (Intercept)   0.1289     0.0992   1.299 1.938e-01 #> x             0.7062     0.1213   5.822 5.819e-09 #>  #>   # Generalized additive mixed model with factor structures -------------------  # The cognition dataset contains simulated measurements of three latent # time-dependent processes, corresponding to individuals' abilities in # cognitive domains. We focus here on the first domain, and take a single # random timepoint per person: dat <- subset(cognition, domain == 1) dat <- split(dat, f = dat$id) dat <- lapply(dat, function(x) x[x$timepoint %in% sample(x$timepoint, 1), ]) dat <- do.call(rbind, dat) dat$item <- factor(dat$item)  # At each timepoint there are three items measuring ability in the cognitive # domain. We fix the factor loading for the first measurement to one, and # estimate the remaining two. This is specified in the loading matrix. loading_matrix <- matrix(c(1, NA, NA), ncol = 1)  # We can now estimate the model. mod <- galamm(   formula = y ~ 0 + item + sl(x, load.var = \"loading\") +     (0 + loading | id),   data = dat,   load.var = \"item\",   lambda = list(loading_matrix),   factor = list(\"loading\") )  # We can plot the estimated smooth term plot_smooth(mod, shade = TRUE)    # Interaction between observed and latent covariates ------------------------ # Define the loading matrix lambda <- list(matrix(c(1, NA, NA), ncol = 1))  # Define the regression functions, one for each row in the loading matrix factor_interactions <- list(list(~ 1, ~ 1, ~ x))  # Fit the model mod <- galamm(             formula = y ~ type + x:response + (0 + loading | id),             data = latent_covariates,             load.var = \"type\",             lambda = lambda,             factor = list(\"loading\"),             factor_interactions = factor_interactions)  # The summary output now include an interaction between the latent variable # and x, for predicting the third element in \"type\" summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ type + x:response + (0 + loading | id) #>    Data: latent_covariates #>  #>      AIC      BIC   logLik deviance df.resid  #>    138.3    177.9    -60.2    120.3      591  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -2.2033 -0.5251 -0.0273  0.5146  3.5029  #>  #> Lambda: #>           loading      SE #> lambda1    1.0000       . #> lambda2    1.3034 0.01268 #> lambda3   -0.3183 0.01604 #> lambda4_x  0.2331 0.02873 #>  #> Random effects: #>  Groups   Name    Variance Std.Dev. #>  id       loading 0.98175  0.9908   #>  Residual         0.01164  0.1079   #> Number of obs: 600, groups:  id, 200 #>  #> Fixed effects: #>                   Estimate Std. Error  t value  Pr(>|t|) #> (Intercept)      -0.010589    0.07048 -0.15024 8.806e-01 #> typemeasurement2 -0.002173    0.02384 -0.09116 9.274e-01 #> typeresponse      0.034005    0.09417  0.36109 7.180e-01 #> x:response        0.462507    0.03300 14.01556 1.252e-44 #>  #>"},{"path":"https://lcbc-uio.github.io/galamm/reference/galamm_control.html","id":null,"dir":"Reference","previous_headings":"","what":"Control values for galamm fit — galamm_control","title":"Control values for galamm fit — galamm_control","text":"function can called controling optimization procedure used fitting GALAMMs using galamm.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/galamm_control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Control values for galamm fit — galamm_control","text":"","code":"galamm_control(   optim_control = list(),   method = c(\"L-BFGS-B\", \"Nelder-Mead\"),   maxit_conditional_modes = 10,   pwirls_tol_abs = 0.01,   reduced_hessian = FALSE )"},{"path":"https://lcbc-uio.github.io/galamm/reference/galamm_control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Control values for galamm fit — galamm_control","text":"optim_control List containing optimization parameters. method   = \"L-BFGS-B\" passed stats::optim's control argument method = \"Nelder-Mead\", passed lme4::Nelder_Mead's control argument. otherwise specified, method = \"L-BFGS-B\", following arguments set non-default values: fnscale = -1 lmm = 20. method Character string defining algorithm used maximizing marginal log-likelihood. default \"L-BFGS-B\", uses limited memory Broyden-Fletcher-Goldfarb-Shanno algorithm box constrained implemented stats::optim. options \"Nelder-Mead\", calls Nelder-Mead algorithm box constraints implemented lme4::Nelder_Mead. maxit_conditional_modes Maximum number iterations penalized iteratively reweighted least squares algorithm. Ignored family =   \"gaussian\" observations, since single step gives exact answer. pwirls_tol_abs Absolute convergence criterion penalized iteratively reweighted least squares algorithm. Defaults 0.01, means reduction marginal likelihood two iterations 0.01, iterations stop. reduced_hessian Logical value. Defaults TRUE, means full Hessian matrix maximum marginal likelihood solution computed. FALSE, reduced Hessian matrix second order partial derivatives respect fixed regression coefficients factor loadings. latter can help full Hessian positive definite.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/galamm_control.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Control values for galamm fit — galamm_control","text":"Object class galamm_control, typically provided argument galamm.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/galamm_control.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Control values for galamm fit — galamm_control","text":"Bates DM, Mächler M, Bolker B, Walker S (2015). “Fitting Linear Mixed-Effects Models Using Lme4.” Journal Statistical Software, 67(1), 1--48. ISSN 1548-7660, doi:10.18637/jss.v067.i01 . BROYDEN CG (1970). “Convergence Class Double-rank Minimization Algorithms 1. General Considerations.” IMA Journal Applied Mathematics, 6(1), 76--90. ISSN 0272-4960, doi:10.1093/imamat/6.1.76 . Byrd RH, Lu P, Nocedal J, Zhu C (1995). “Limited Memory Algorithm Bound Constrained Optimization.” SIAM Journal Scientific Computing, 16(5), 1190--1208. ISSN 1064-8275, doi:10.1137/0916069 . Fletcher R (1970). “New Approach Variable Metric Algorithms.” Computer Journal, 13(3), 317--322. ISSN 0010-4620, doi:10.1093/comjnl/13.3.317 . Goldfarb D (1970). “Family Variable-Metric Methods Derived Variational Means.” Mathematics Computation, 24(109), 23--26. ISSN 0025-5718, 1088-6842, doi:10.1090/S0025-5718-1970-0258249-6 . Nelder JA, Mead R (1965). “Simplex Method Function Minimization.” Computer Journal, 7(4), 308--313. ISSN 0010-4620, doi:10.1093/comjnl/7.4.308 . Shanno DF (1970). “Conditioning Quasi-Newton Methods Function Minimization.” Mathematics Computation, 24(111), 647--656. ISSN 0025-5718, 1088-6842, doi:10.1090/S0025-5718-1970-0274029-X .","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/galamm_control.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Control values for galamm fit — galamm_control","text":"","code":"# Define control object with quite a high degree of verbosity (trace = 6) # and using the last 20 BFGS updates to estimate the Hessian in L-BFGS-B. control <- galamm_control(optim_control = list(trace = 6, lmm = 20))"},{"path":"https://lcbc-uio.github.io/galamm/reference/hsced.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Data with Heteroscedastic Residuals — hsced","title":"Example Data with Heteroscedastic Residuals — hsced","text":"Simulated dataset residual standard deviation varies items.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/hsced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Data with Heteroscedastic Residuals — hsced","text":"","code":"hsced"},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/hsced.html","id":"hsced-a-data-frame-with-rows-and-columns-","dir":"Reference","previous_headings":"","what":"hsced A data frame with 1200 rows and 5 columns:","title":"Example Data with Heteroscedastic Residuals — hsced","text":"id Subject ID. age Timepoint. item Item indicator. x Explanatory variable y Outcome.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/hsced.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Example Data with Heteroscedastic Residuals — hsced","text":"references Rd macro \\insertAllCites help page.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/latent_covariates.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated Data with Latent and Observed Covariates Interaction — latent_covariates","title":"Simulated Data with Latent and Observed Covariates Interaction — latent_covariates","text":"Simulated dataset use examples testing latent covariate interacting observed covariate.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/latent_covariates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated Data with Latent and Observed Covariates Interaction — latent_covariates","text":"","code":"latent_covariates"},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/latent_covariates.html","id":"latent-covariates-a-data-frame-with-rows-and-columns-","dir":"Reference","previous_headings":"","what":"latent_covariates A data frame with 600 rows and 5 columns:","title":"Simulated Data with Latent and Observed Covariates Interaction — latent_covariates","text":"id Subject ID. type Type observation y variable. equals \"measurement1\" \"measurement2\" observation measurement latent variable. equals \"response\", observation actual response. x Explanatory variable. y Observed response. Note, includes actual response, measurements latent variable, since mathematically treated responses. response Dummy variable indicating whether given row response .","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/latent_covariates_long.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated Longitudinal Data with Latent and Observed Covariates Interaction — latent_covariates_long","title":"Simulated Longitudinal Data with Latent and Observed Covariates Interaction — latent_covariates_long","text":"Simulated dataset use examples testing latent covariate interacting observed covariate. data, response measured six times subject.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/latent_covariates_long.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated Longitudinal Data with Latent and Observed Covariates Interaction — latent_covariates_long","text":"","code":"latent_covariates_long"},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/latent_covariates_long.html","id":"latent-covariates-long-a-data-frame-with-rows-and-","dir":"Reference","previous_headings":"","what":"latent_covariates_long A data frame with 800 rows and 5","title":"Simulated Longitudinal Data with Latent and Observed Covariates Interaction — latent_covariates_long","text":"columns: id Subject ID. type Type observation y variable. equals \"measurement1\" \"measurement2\" observation measurement latent variable. equals \"response\", observation actual response. x Explanatory variable. y Observed response. Note, includes actual response, measurements latent variable, since mathematically treated responses. response Dummy variable indicating whether given row response .","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/llikAIC.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract log likelihood, AIC, and related statistics from a GALAMM — llikAIC","title":"Extract log likelihood, AIC, and related statistics from a GALAMM — llikAIC","text":"function assembles values used summary.galamm.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/llikAIC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract log likelihood, AIC, and related statistics from a GALAMM — llikAIC","text":"","code":"llikAIC(object)"},{"path":"https://lcbc-uio.github.io/galamm/reference/llikAIC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract log likelihood, AIC, and related statistics from a GALAMM — llikAIC","text":"object Object class galamm returned galamm.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/llikAIC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract log likelihood, AIC, and related statistics from a GALAMM — llikAIC","text":"list containing AIC, BIC, log likelihood, deviance residual degrees freedom.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/logLik.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Log-Likelihood of galamm Object — logLik.galamm","title":"Extract Log-Likelihood of galamm Object — logLik.galamm","text":"Extract Log-Likelihood galamm Object","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/logLik.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Log-Likelihood of galamm Object — logLik.galamm","text":"","code":"# S3 method for galamm logLik(object, ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/logLik.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Log-Likelihood of galamm Object — logLik.galamm","text":"object Object ... arguments","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/logLik.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Log-Likelihood of galamm Object — logLik.galamm","text":"Object class logLik","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/logLik.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Log-Likelihood of galamm Object — logLik.galamm","text":"","code":"# Linear mixed model with heteroscedastic residuals mod <- galamm(   formula = y ~ x + (1 | id),   weights = ~ (1 | item),   data = hsced )  # Extract log likelihood logLik(mod) #> 'log Lik.' -2058.14 (df=5)"},{"path":"https://lcbc-uio.github.io/galamm/reference/mresp.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated Mixed Response Data — mresp","title":"Simulated Mixed Response Data — mresp","text":"basic mixed response dataset one set normally distributed responses one set binomially distributed responses.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/mresp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated Mixed Response Data — mresp","text":"","code":"mresp"},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/mresp.html","id":"mresp-a-data-frame-with-rows-and-columns-","dir":"Reference","previous_headings":"","what":"mresp A data frame with 4000 rows and 5 columns:","title":"Simulated Mixed Response Data — mresp","text":"id Subject ID. x Predictor variable. y Response. itemgroup Factor variable equals \"\" normally distributed responses \"b\" binomially distributed response (1 trial).","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/mresp_hsced.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated Mixed Response Data with Heteroscedastic Residuals — mresp_hsced","title":"Simulated Mixed Response Data with Heteroscedastic Residuals — mresp_hsced","text":"Mixed response dataset one set normally distributed responses one set binomially distributed responses. normally distributed response follow two different residual standard deviations.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/mresp_hsced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated Mixed Response Data with Heteroscedastic Residuals — mresp_hsced","text":"","code":"mresp_hsced"},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/mresp_hsced.html","id":"mresp-a-data-frame-with-rows-and-columns-","dir":"Reference","previous_headings":"","what":"mresp A data frame with 4000 rows and 5 columns:","title":"Simulated Mixed Response Data with Heteroscedastic Residuals — mresp_hsced","text":"id Subject ID. x Predictor variable. y Response. itemgroup Factor variable equals \"\" normally distributed responses \"b\" binomially distributed response (1 trial). grp Grouping variable denoting two residual standard deviations apply. relevant normally distributed responses. isgauss Dummy variable indicating whether observation given line normally (Gaussian) distributed .","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/nobs.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the Number of Observations from a galamm Fit — nobs.galamm","title":"Extract the Number of Observations from a galamm Fit — nobs.galamm","text":"Extract Number Observations galamm Fit","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/nobs.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the Number of Observations from a galamm Fit — nobs.galamm","text":"","code":"# S3 method for galamm nobs(object, ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/nobs.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the Number of Observations from a galamm Fit — nobs.galamm","text":"object galamm object ... arguments","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/nobs.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the Number of Observations from a galamm Fit — nobs.galamm","text":"number","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/plot.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Diagnostic plots for galamm objects — plot.galamm","title":"Diagnostic plots for galamm objects — plot.galamm","text":"Diagnostic plots galamm objects","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/plot.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diagnostic plots for galamm objects — plot.galamm","text":"","code":"# S3 method for galamm plot(x, ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/plot.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diagnostic plots for galamm objects — plot.galamm","text":"x object class galamm returned galamm. ... Optional arguments passed plot function.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/plot.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Diagnostic plots for galamm objects — plot.galamm","text":"plot displayed.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/plot.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Diagnostic plots for galamm objects — plot.galamm","text":"","code":"# Linear mixed model example from lme4 data(\"sleepstudy\", package = \"lme4\") mod <- galamm(Reaction ~ Days + (Days | Subject), data = sleepstudy)  # Diagnostic plot plot(mod)"},{"path":"https://lcbc-uio.github.io/galamm/reference/plot_smooth.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot smooth terms for galamm fits — plot_smooth.galamm","title":"Plot smooth terms for galamm fits — plot_smooth.galamm","text":"Plots smooth terms fitted galamm object. function thin wrapper around mgcv::plot.gam (Wood 2017) .","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/plot_smooth.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot smooth terms for galamm fits — plot_smooth.galamm","text":"","code":"# S3 method for galamm plot_smooth(object, ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/plot_smooth.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot smooth terms for galamm fits — plot_smooth.galamm","text":"object Object class galamm returned galamm. ... optional arguments, passed mgcv::plot.gam.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/plot_smooth.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot smooth terms for galamm fits — plot_smooth.galamm","text":"plot displayed screen.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/plot_smooth.galamm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plot smooth terms for galamm fits — plot_smooth.galamm","text":"Wood SN (2017). Generalized Additive Models: Introduction R, 2 edition. Chapman Hall/CRC.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/plot_smooth.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot smooth terms for galamm fits — plot_smooth.galamm","text":"","code":"# Generalized additive mixed model with factor structures -------------------  # The cognition dataset contains simulated measurements of three latent # time-dependent processes, corresponding to individuals' abilities in # cognitive domains. We focus here on the first domain, and take a single # random timepoint per person: dat <- subset(cognition, domain == 1) dat <- split(dat, f = dat$id) dat <- lapply(dat, function(x) x[x$timepoint %in% sample(x$timepoint, 1), ]) dat <- do.call(rbind, dat) dat$item <- factor(dat$item)  # At each timepoint there are three items measuring ability in the cognitive # domain. We fix the factor loading for the first measurement to one, and # estimate the remaining two. This is specified in the loading matrix. loading_matrix <- matrix(c(1, NA, NA), ncol = 1)  # We can now estimate the model. mod <- galamm(   formula = y ~ 0 + item + sl(x, load.var = \"loading\") +     (0 + loading | id),   data = dat,   load.var = \"item\",   lambda = list(loading_matrix),   factor = list(\"loading\") )  # We can plot the estimated smooth term plot_smooth(mod, shade = TRUE)   # We can turn off the rug at the bottom plot_smooth(mod, shade = TRUE, rug = FALSE)"},{"path":"https://lcbc-uio.github.io/galamm/reference/predict.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictions from a model at new data values — predict.galamm","title":"Predictions from a model at new data values — predict.galamm","text":"Currently, predictions given random effects set zero. add opportunity specify level prediction future. particularly important models containing smooth terms, predictions currently make much sense.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/predict.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictions from a model at new data values — predict.galamm","text":"","code":"# S3 method for galamm predict(object, newdata = NULL, type = c(\"link\", \"response\"), ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/predict.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictions from a model at new data values — predict.galamm","text":"object object class galamm returned galamm. newdata Data evaluate predictions. Defaults \"NULL\", means predictions evaluate data used fit model. type Type prediction object returned. ... Optional arguments passed methods. Currently used.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/predict.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predictions from a model at new data values — predict.galamm","text":"numeric vector predicted values.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/predict.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predictions from a model at new data values — predict.galamm","text":"","code":"# Poisson GLMM count_mod <- galamm(   formula = y ~ lbas * treat + lage + v4 + (1 | subj),   data = epilep, family = poisson )  # Plot response versus link: plot(   predict(count_mod, type = \"link\"),   predict(count_mod, type = \"response\") )"},{"path":"https://lcbc-uio.github.io/galamm/reference/print.VarCorr.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for variance-covariance objects — print.VarCorr.galamm","title":"Print method for variance-covariance objects — print.VarCorr.galamm","text":"Print method variance-covariance objects","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/print.VarCorr.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for variance-covariance objects — print.VarCorr.galamm","text":"","code":"# S3 method for VarCorr.galamm print(   x,   digits = max(3, getOption(\"digits\") - 2),   comp = c(\"Std.Dev.\", \"Variance\"),   corr = any(comp == \"Std.Dev.\"),   ... )"},{"path":"https://lcbc-uio.github.io/galamm/reference/print.VarCorr.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for variance-covariance objects — print.VarCorr.galamm","text":"x object class VarCorr.galamm, returned VarCorr.galamm. digits Optional arguments specifying number digits use printing. comp Character vector length 1 2 specifying variance components print. corr Boolean indicating whether covariances correlations printed. ... Optional arguments passed methods. Currently used.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/print.VarCorr.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for variance-covariance objects — print.VarCorr.galamm","text":"variance-covariance information printed console argument x silently returned.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/print.VarCorr.galamm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Print method for variance-covariance objects — print.VarCorr.galamm","text":"Bates DM, Mächler M, Bolker B, Walker S (2015). “Fitting Linear Mixed-Effects Models Using Lme4.” Journal Statistical Software, 67(1), 1--48. ISSN 1548-7660, doi:10.18637/jss.v067.i01 .","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/print.VarCorr.galamm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print method for variance-covariance objects — print.VarCorr.galamm","text":"function derived lme4:::print.VarCorr.merMod written Douglas M. Bates, Martin Maechler, Ben Bolker, Steve Walker.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/print.VarCorr.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print method for variance-covariance objects — print.VarCorr.galamm","text":"","code":"# Linear mixed model with heteroscedastic residuals mod <- galamm(   formula = y ~ x + (1 | id),   weights = ~ (1 | item),   data = hsced )  # Extract information on variance and covariance VarCorr(mod) #>  Groups   Name        Std.Dev. Variance #>  id       (Intercept) 0.99400  0.98804  #>  Residual             0.97964  0.95970"},{"path":"https://lcbc-uio.github.io/galamm/reference/print.summary.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for summary GALAMM fits — print.summary.galamm","title":"Print method for summary GALAMM fits — print.summary.galamm","text":"Print method summary GALAMM fits","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/print.summary.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for summary GALAMM fits — print.summary.galamm","text":"","code":"# S3 method for summary.galamm print(x, digits = max(3, getOption(\"digits\") - 3), ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/print.summary.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for summary GALAMM fits — print.summary.galamm","text":"x object class summary.galamm returned summary.galamm. digits Number digits present outputs. ... arguments passed methods. Currently used stats::printCoefmat printing approximate significance smooth terms.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/print.summary.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for summary GALAMM fits — print.summary.galamm","text":"Summary printed screen. Invisibly returns argument x.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/print.summary.galamm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Print method for summary GALAMM fits — print.summary.galamm","text":"Bates DM, Mächler M, Bolker B, Walker S (2015). “Fitting Linear Mixed-Effects Models Using Lme4.” Journal Statistical Software, 67(1), 1--48. ISSN 1548-7660, doi:10.18637/jss.v067.i01 .","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/print.summary.galamm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print method for summary GALAMM fits — print.summary.galamm","text":"code producing summary information derived summary methods mgcv (author: Simon Wood) lme4 (Bates et al. 2015)  (authors: Douglas M. Bates, Martin Maechler, Ben Bolker, Steve Walker).","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/print.summary.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print method for summary GALAMM fits — print.summary.galamm","text":"","code":"# Linear mixed model with heteroscedastic residuals mod <- galamm(   formula = y ~ x + (1 | id),   weights = ~ (1 | item),   data = hsced )  summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ x + (1 | id) #>    Data: hsced #> Weights: ~(1 | item) #>  #>      AIC      BIC   logLik deviance df.resid  #>   4126.3   4151.7  -2058.1   4116.3     1195  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -5.6545 -0.7105  0.0286  0.6827  4.3261  #>  #> Random effects: #>  Groups   Name        Variance Std.Dev. #>  id       (Intercept) 0.9880   0.9940   #>  Residual             0.9597   0.9796   #> Number of obs: 1200, groups:  id, 200 #>  #> Variance function: #>     1     2  #> 1.000 1.995  #>  #> Fixed effects: #>             Estimate Std. Error t value  Pr(>|t|) #> (Intercept)   0.1289     0.0992   1.299 1.938e-01 #> x             0.7062     0.1213   5.822 5.819e-09 #>  #>"},{"path":"https://lcbc-uio.github.io/galamm/reference/ranef.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract random effects from galamm object. — ranef.galamm","title":"Extract random effects from galamm object. — ranef.galamm","text":"Extract random effects galamm object.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/ranef.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract random effects from galamm object. — ranef.galamm","text":"","code":"# S3 method for galamm ranef(object, ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/ranef.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract random effects from galamm object. — ranef.galamm","text":"object object class galamm, returned galamm. ... Optional parameters passed methods. Currently used.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/ranef.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract random effects from galamm object. — ranef.galamm","text":"object class ranef.galamm, containing requested random effects.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/ranef.galamm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract random effects from galamm object. — ranef.galamm","text":"Bates DM, Mächler M, Bolker B, Walker S (2015). “Fitting Linear Mixed-Effects Models Using Lme4.” Journal Statistical Software, 67(1), 1--48. ISSN 1548-7660, doi:10.18637/jss.v067.i01 .","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/ranef.galamm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract random effects from galamm object. — ranef.galamm","text":"function derived lme4::ranef.merMod, written Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/ranef.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract random effects from galamm object. — ranef.galamm","text":"","code":"# Poisson GLMM count_mod <- galamm(   formula = y ~ lbas * treat + lage + v4 + (1 | subj),   data = epilep, family = poisson )  # Extract random effects ranef(count_mod) #> $subj #>     (Intercept) #> 1   0.054801194 #> 2   0.067128734 #> 3   0.339005443 #> 4   0.156539399 #> 5   0.018769146 #> 6  -0.203361347 #> 7  -0.121249992 #> 8   0.445388051 #> 9  -0.183126098 #> 10  0.941223293 #> 11  0.164707632 #> 12 -0.013318772 #> 13 -0.069755556 #> 14 -0.080784157 #> 15 -0.220238514 #> 16 -0.856980819 #> 17 -0.756729929 #> 18  0.192712910 #> 19 -0.247883354 #> 20 -0.109262155 #> 21  0.020112309 #> 22  0.336336442 #> 23 -0.312726250 #> 24  0.097464659 #> 25  0.959569912 #> 26 -0.457892584 #> 27  0.039653228 #> 28  0.263425805 #> 29 -0.311198889 #> 30 -0.155081893 #> 31 -0.320528837 #> 32  0.539457657 #> 33  0.460522482 #> 34 -0.305186294 #> 35  1.018964462 #> 36  0.548834571 #> 37  0.275759175 #> 38 -0.688740932 #> 39 -0.046734600 #> 40  0.005348547 #> 41 -0.569016659 #> 42  0.134020686 #> 43  0.392476777 #> 44  0.016707046 #> 45  0.100750799 #> 46  0.381237132 #> 47  0.109689790 #> 48 -0.373107851 #> 49  0.686635579 #> 50 -0.212730301 #> 51 -0.194902788 #> 52 -0.772084418 #> 53  0.443822432 #> 54 -0.389679998 #> 55  0.201819631 #> 56  1.101943180 #> 57 -0.645241909 #> 58 -0.938185103 #> 59  0.094489081 #>  #> attr(,\"class\") #> [1] \"ranef.galamm\""},{"path":"https://lcbc-uio.github.io/galamm/reference/residuals.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Residuals of galamm objects — residuals.galamm","title":"Residuals of galamm objects — residuals.galamm","text":"Residuals galamm objects","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/residuals.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residuals of galamm objects — residuals.galamm","text":"","code":"# S3 method for galamm residuals(object, type = c(\"pearson\", \"deviance\"), ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/residuals.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residuals of galamm objects — residuals.galamm","text":"object object class galamm returned galamm. type Type residuals returned. One \"pearson\" \"deviance\". ... Optional arguments passed methods. Currently used.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/residuals.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residuals of galamm objects — residuals.galamm","text":"Numeric vector residual values.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/residuals.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Residuals of galamm objects — residuals.galamm","text":"","code":"# Poisson GLMM count_mod <- galamm(   formula = y ~ lbas * treat + lage + v4 + (1 | subj),   data = epilep, family = poisson )  # Extract residuals residuals(count_mod) #>   [1]  0.75134825 -0.30588389 -0.30588389 -0.02647642 -0.29969105  0.75942563 #>   [7] -0.29969105 -0.02030696 -0.31982773  0.94348448 -1.58313993  1.96255720 #>  [13]  0.43844044  0.43844044 -1.23495860  0.76431835 -1.92290673  0.98985619 #>  [19] -1.39331347  2.54290384 -0.37901975 -1.61176436  0.85372485  0.87239664 #>  [25]  1.53250415  0.42157251 -1.80029078 -0.45686210  3.20970074 -0.85522137 #>  [31] -0.24548305 -1.89587259 -0.37109232  0.04054904  0.04054904 -0.01046534 #>  [37]  2.32295391  1.96014958 -0.57948072 -2.54300871  2.19282080 -1.20593505 #>  [43] -2.66254471  1.98848496  1.50225502 -0.64560897  0.07034569 -1.02528638 #>  [49] -0.11018739 -0.11018739  0.86264510 -0.84232934 -1.20333646 -0.60001269 #>  [55]  0.30497297  1.51905875  0.11484915  2.14376752 -1.40683963 -1.16387436 #>  [61]  2.65545389 -2.24478741 -2.24478741  0.34313328 -1.52938364 -1.52938364 #>  [67]  0.43219090  0.71507238  0.93383050 -0.48618501 -0.66368695  0.38154208 #>  [73] -0.56482022  0.41685518 -1.05565792  0.78036317 -0.61348596 -2.06574589 #>  [79]  0.83877398  1.76694279 -0.32319792  0.20279343 -0.32319792  0.52638912 #>  [85] -0.15886014  0.39262021 -0.15886014  0.71796768 -0.88312263 -0.36313065 #>  [91] -0.36313065  1.04374857  0.11210337  1.55462045 -2.05167224  0.56867360 #>  [97] -3.01755708 -2.01950534  6.63027648 -1.03914103 -0.02145063 -0.72321509 #> [103] -0.02145063 -0.55408107  0.27795300 -0.97310964  0.90348433 -0.11893239 #> [109] -0.13340625  0.41112684 -0.13340625  0.15259422 -0.06770284  0.82764610 #> [115] -0.66460214 -0.50349772  0.20892340 -0.15792875  0.57577555 -0.92446003 #> [121] -1.46575702  1.26320826  0.58096694 -1.35232878  0.10795686  1.89482700 #> [127] -1.08328990  0.38775621 -1.16421688  0.73022624  1.20383702  0.10529799 #> [133]  0.46538682 -0.09615929 -1.21925153  0.18294961  0.90033033 -0.27288190 #> [139]  0.19640299  0.13717193  0.17355958 -0.29134663  1.10337200  0.03108554 #> [145] -0.20516397  1.11018319 -1.52051113  1.44850131 -1.49633342  0.02175214 #> [151]  0.02175214  0.44848458 -1.29984938  3.78574203 -2.02636244 -0.57121746 #> [157]  0.95126708 -0.03257705 -0.03257705 -0.93776498 -1.46467211 -0.09917878 #> [163]  1.26631454 -1.35132783  1.17204252  0.59252146 -1.72556281  0.29235793 #> [169] -1.34839757 -0.60923644  2.10102101  0.26122160  1.25864008 -0.66816476 #> [175] -1.43888670  0.94731198  2.83566561 -0.95477231 -1.27064214 -0.52432300 #> [181] -0.35539104 -0.35539104  0.48257860  1.62375415 -0.76701612  0.63019867 #> [187] -0.06840872  0.38751946  0.77476967 -0.15207809 -1.07892584 -0.99543270 #> [193]  2.75568498 -1.44160278 -0.64752131 -0.38687286  0.21353124 -0.31387209 #> [199] -0.84127542  0.53720677  0.39735678 -0.36116194 -0.74042129  0.44481689 #> [205] -1.29929849 -0.21360713 -1.29929849  1.24229858  0.06700104 -1.59599420 #> [211]  2.44270852 -0.53607134  1.14333078 -0.40015859  0.11433786 -1.79323794 #> [217] -0.35757659  0.68406717  0.16324529 -0.07793957 -3.19183238  3.13136837 #> [223]  1.98169550 -0.71780112 -0.15016611  0.52039502 -1.49128836 -0.64907910 #> [229] -0.98405084 -0.98405084 -0.98405084 -0.90789964 -0.94826426  0.94946156 #> [235]  0.31688629 -0.08723898"},{"path":"https://lcbc-uio.github.io/galamm/reference/sigma.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract square root of dispersion parameter from galamm object — sigma.galamm","title":"Extract square root of dispersion parameter from galamm object — sigma.galamm","text":"Extracts square root dispersion parameter(s) object class galamm, returned galamm. case conditionally Gaussian responses, residual standard deviation. multiple dispersion parameters, e.g., mixed response type models, square root returned numeric vector.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/sigma.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract square root of dispersion parameter from galamm object — sigma.galamm","text":"","code":"# S3 method for galamm sigma(object, ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/sigma.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract square root of dispersion parameter from galamm object — sigma.galamm","text":"object object class galamm. ... optional arguments. Currently used.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/sigma.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract square root of dispersion parameter from galamm object — sigma.galamm","text":"square root one dispersion parameters.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/sigma.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract square root of dispersion parameter from galamm object — sigma.galamm","text":"","code":"# Linear mixed model with heteroscedastic residuals mod <- galamm(   formula = y ~ x + (1 | id),   weights = ~ (1 | item),   data = hsced )  # Extract residual standard deviation. sigma(mod) #> [1] 0.9796427  # The residual standard deviation applies to the base case. The variance # function shown in the model output shows the estimated multiplier for # various grouping levels: summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ x + (1 | id) #>    Data: hsced #> Weights: ~(1 | item) #>  #>      AIC      BIC   logLik deviance df.resid  #>   4126.3   4151.7  -2058.1   4116.3     1195  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -5.6545 -0.7105  0.0286  0.6827  4.3261  #>  #> Random effects: #>  Groups   Name        Variance Std.Dev. #>  id       (Intercept) 0.9880   0.9940   #>  Residual             0.9597   0.9796   #> Number of obs: 1200, groups:  id, 200 #>  #> Variance function: #>     1     2  #> 1.000 1.995  #>  #> Fixed effects: #>             Estimate Std. Error t value  Pr(>|t|) #> (Intercept)   0.1289     0.0992   1.299 1.938e-01 #> x             0.7062     0.1213   5.822 5.819e-09 #>  #>"},{"path":"https://lcbc-uio.github.io/galamm/reference/sl.html","id":null,"dir":"Reference","previous_headings":"","what":"Set up smooth term with factor loading — s","title":"Set up smooth term with factor loading — s","text":"thin wrapper around mgcv::s. enables specification loading variables smooth terms. last letter \"l\", stands \"loading\", added avoid namespace conflicts mgcv gamm4.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/sl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set up smooth term with factor loading — s","text":"","code":"sl(..., load.var = NULL)"},{"path":"https://lcbc-uio.github.io/galamm/reference/sl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set up smooth term with factor loading — s","text":"... Arguments passed mgcv::s. load.var Optional character argument specifying loading variable.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/sl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set up smooth term with factor loading — s","text":"object class xx.smooth.spec, xx basis identifying code given bs argument s. differs smooth returned mgcv::s additional attribute named \"load.var\" specifies factor loading smooth term multiplied order produce observed outcome.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/sl.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Set up smooth term with factor loading — s","text":"Wood SN (2003). “Thin Plate Regression Splines.” Journal Royal Statistical Society. Series B (Statistical Methodology), 65(1), 95--114. ISSN 1369-7412. Wood SN (2017). Generalized Additive Models: Introduction R, 2 edition. Chapman Hall/CRC.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/sl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set up smooth term with factor loading — s","text":"","code":"# Linear mixed model with factor structures dat <- subset(cognition, domain == 1 & timepoint == 1) loading_matrix <- matrix(c(1, NA, NA), ncol = 1)   # Model with four thin-plate regression splines as basis functions mod <- galamm(   formula = y ~ 0 + item + sl(x, k = 4, load.var = \"loading\"),   data = dat,   load.var = \"item\",   lambda = list(loading_matrix),   factor = list(\"loading\") )  # Model with four cubic regression splines as basis functions mod <- galamm(   formula = y ~ 0 + item +     sl(x, bs = \"cr\", k = 4, load.var = \"loading\"),   data = dat,   load.var = \"item\",   lambda = list(loading_matrix),   factor = list(\"loading\") )  # The sl function will rarely be called directly, but if done, it returns # data needed to set up the smooth terms. a <- sl(x, load.var = \"loading\")"},{"path":"https://lcbc-uio.github.io/galamm/reference/summary.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarizing GALAMM fits — summary.galamm","title":"Summarizing GALAMM fits — summary.galamm","text":"Summary method class \"galamm\".","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/summary.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarizing GALAMM fits — summary.galamm","text":"","code":"# S3 method for galamm summary(object, ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/summary.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarizing GALAMM fits — summary.galamm","text":"object object class galamm returned galamm. ... arguments passed methods. Currently used.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/summary.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarizing GALAMM fits — summary.galamm","text":"list summary statistics fitted model class summary.galamm, containing following elements: AICtab table model fit measures, returned llikAIC. call matched call used fitting model. fixef matrix fixed effect estimated, returned fixef. gam List containing information smooth terms model. smooth terms contained model, list length zero. model list various elements related model setup fit. See ?galamm details. parameters list object model parameters related information. See ?galamm details. Lambda object containing estimated factor loadings. Returned factor_loadings.galamm. estimated factor loadings, object NULL. random_effects list containing random effects. See ?galamm details. VarCorr object class VarCorr.galamm, returned VarCorr.galamm. weights object containing information estimated variance functions, heteroscedastic residuals. Otherwise object NULL.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/summary.galamm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summarizing GALAMM fits — summary.galamm","text":"code producing summary information derived summary methods mgcv (author: Simon Wood) lme4 (Bates et al. 2015)  (authors: Douglas M. Bates, Martin Maechler, Ben Bolker, Steve Walker).","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/summary.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarizing GALAMM fits — summary.galamm","text":"","code":"# Linear mixed model with heteroscedastic residuals mod <- galamm(   formula = y ~ x + (1 | id),   weights = ~ (1 | item),   data = hsced )  summary(mod) #> GALAMM fit by maximum marginal likelihood. #> Formula: y ~ x + (1 | id) #>    Data: hsced #> Weights: ~(1 | item) #>  #>      AIC      BIC   logLik deviance df.resid  #>   4126.3   4151.7  -2058.1   4116.3     1195  #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -5.6545 -0.7105  0.0286  0.6827  4.3261  #>  #> Random effects: #>  Groups   Name        Variance Std.Dev. #>  id       (Intercept) 0.9880   0.9940   #>  Residual             0.9597   0.9796   #> Number of obs: 1200, groups:  id, 200 #>  #> Variance function: #>     1     2  #> 1.000 1.995  #>  #> Fixed effects: #>             Estimate Std. Error t value  Pr(>|t|) #> (Intercept)   0.1289     0.0992   1.299 1.938e-01 #> x             0.7062     0.1213   5.822 5.819e-09 #>  #>"},{"path":"https://lcbc-uio.github.io/galamm/reference/t2l.html","id":null,"dir":"Reference","previous_headings":"","what":"Set up smooth term with factor loading — t2","title":"Set up smooth term with factor loading — t2","text":"thin wrapper around mgcv::t2. enables specification loading variables smooth terms. last letter \"l\", stands \"loading\", added avoid namespace conflicts mgcv gamm4.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/t2l.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set up smooth term with factor loading — t2","text":"","code":"t2l(..., load.var = NULL)"},{"path":"https://lcbc-uio.github.io/galamm/reference/t2l.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set up smooth term with factor loading — t2","text":"... Arguments passed mgcv::t2. load.var Optional character argument specifying loading variable.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/t2l.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set up smooth term with factor loading — t2","text":"object class xx.smooth.spec, xx basis identifying code given bs argument t2. differs smooth returned mgcv::s additional attribute named \"load.var\" specifies factor loading smooth term multiplied order produce observed outcome.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/t2l.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Set up smooth term with factor loading — t2","text":"Wood SN (2003). “Thin Plate Regression Splines.” Journal Royal Statistical Society. Series B (Statistical Methodology), 65(1), 95--114. ISSN 1369-7412. Wood SN (2017). Generalized Additive Models: Introduction R, 2 edition. Chapman Hall/CRC.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/t2l.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set up smooth term with factor loading — t2","text":"","code":"# Linear mixed model with factor structures dat <- subset(cognition, domain == 1 & timepoint == 1) loading_matrix <- matrix(c(1, NA, NA), ncol = 1)  # Model with four cubic regression splines as basis functions mod <- galamm(   formula = y ~ 0 + item + t2l(x, k = 4, load.var = \"loading\"),   data = dat,   load.var = \"item\",   lambda = list(loading_matrix),   factor = list(\"loading\") )  # Model with four thin-plate regression splines as basis functions mod <- galamm(   formula = y ~ 0 + item +     t2l(x, bs = \"tp\", k = 4, load.var = \"loading\"),   data = dat,   load.var = \"item\",   lambda = list(loading_matrix),   factor = list(\"loading\") )  # The t2l function will rarely be called directly, but if done, it returns # data needed to set up the smooth terms. a <- t2l(x, load.var = \"loading\")"},{"path":"https://lcbc-uio.github.io/galamm/reference/vcov.galamm.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate variance-covariance matrix for GALAMM fit — vcov.galamm","title":"Calculate variance-covariance matrix for GALAMM fit — vcov.galamm","text":"Calculate variance-covariance matrix GALAMM fit","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/vcov.galamm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate variance-covariance matrix for GALAMM fit — vcov.galamm","text":"","code":"# S3 method for galamm vcov(object, parm = \"beta\", ...)"},{"path":"https://lcbc-uio.github.io/galamm/reference/vcov.galamm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate variance-covariance matrix for GALAMM fit — vcov.galamm","text":"object Object class galamm returned galamm. parm parameters variance-covariance matrix calculated. Character vector one elements \"theta\", \"beta\", \"lambda\", \"weights\". Can also integer vector. ... arguments passed methods. Currently used.","code":""},{"path":"https://lcbc-uio.github.io/galamm/reference/vcov.galamm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate variance-covariance matrix for GALAMM fit — vcov.galamm","text":"variance-covariance matrix.","code":""},{"path":[]},{"path":"https://lcbc-uio.github.io/galamm/reference/vcov.galamm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate variance-covariance matrix for GALAMM fit — vcov.galamm","text":"","code":"# Linear mixed model with heteroscedastic residuals mod <- galamm(   formula = y ~ x + (1 | id),   weights = ~ (1 | item),   data = hsced )  # Extract covariance matrix for fixed regression coefficients vcov(mod, parm = \"beta\") #>              [,1]         [,2] #> [1,]  0.009841573 -0.007511908 #> [2,] -0.007511908  0.014715234  # and then for weights, which gives us the variance. vcov(mod, parm = \"weights\") #>             [,1] #> [1,] 0.002459613"}]
